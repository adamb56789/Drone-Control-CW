\documentclass[11pt,a4paper]{report}
\usepackage{color}
\usepackage{ifthen}
\usepackage{ifpdf}
\usepackage[headings]{fullpage}
\usepackage{listings}
\lstset{language=Java,breaklines=true}
\ifpdf \usepackage[pdftex, pdfpagemode={UseOutlines},bookmarks,colorlinks,linkcolor={blue},plainpages=false,pdfpagelabels,citecolor={red},breaklinks=true]{hyperref}
  \usepackage[pdftex]{graphicx}
  \pdfcompresslevel=9
  \DeclareGraphicsRule{*}{mps}{*}{}
\else
  \usepackage[dvips]{graphicx}
\fi

\newcommand{\entityintro}[3]{%
  \hbox to \hsize{%
    \vbox{%
      \hbox to .2in{}%
    }%
    {\bf  #1}%
    \dotfill\pageref{#2}%
  }
  \makebox[\hsize]{%
    \parbox{.4in}{}%
    \parbox[l]{5in}{%
      \vspace{1mm}%
      #3%
      \vspace{1mm}%
    }%
  }%
}
\newcommand{\refdefined}[1]{
\expandafter\ifx\csname r@#1\endcsname\relax
\relax\else
{$($in \ref{#1}, page \pageref{#1}$)$}\fi}
\date{\today}
\title{AQ maps}
\author{s1858833}
\chardef\textbackslash=`\\
\begin{document}
\maketitle
\sloppy
\addtocontents{toc}{\protect\markboth{Contents}{Contents}}
\tableofcontents
\chapter*{Class Hierarchy}{
\thispagestyle{empty}
\markboth{Class Hierarchy}{Class Hierarchy}
\addcontentsline{toc}{chapter}{Class Hierarchy}
\section*{Classes}
{\raggedright
\hspace{0.0cm} $\bullet$ java.lang.Object {\tiny \refdefined{java.lang.Object}} \\
\hspace{1.0cm} $\bullet$ java.awt.geom.Point2D {\tiny \refdefined{java.awt.geom.Point2D}} \\
\hspace{2.0cm} $\bullet$ java.awt.geom.Point2D.Double {\tiny \refdefined{java.awt.geom.Point2D.Double}} \\
\hspace{3.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.geometry.Coords {\tiny \refdefined{uk.ac.ed.inf.aqmaps.geometry.Coords}} \\
\hspace{1.0cm} $\bullet$ org.jgrapht.alg.tour.HamiltonianCycleAlgorithmBase {\tiny \refdefined{org.jgrapht.alg.tour.HamiltonianCycleAlgorithmBase}} \\
\hspace{2.0cm} $\bullet$ org.jgrapht.alg.tour.TwoOptHeuristicTSP {\tiny \refdefined{org.jgrapht.alg.tour.TwoOptHeuristicTSP}} \\
\hspace{3.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP {\tiny \refdefined{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP}} \\
\hspace{1.0cm} $\bullet$ org.jgrapht.graph.AbstractGraph {\tiny \refdefined{org.jgrapht.graph.AbstractGraph}} \\
\hspace{2.0cm} $\bullet$ org.jgrapht.graph.AbstractBaseGraph {\tiny \refdefined{org.jgrapht.graph.AbstractBaseGraph}} \\
\hspace{3.0cm} $\bullet$ org.jgrapht.graph.SimpleGraph {\tiny \refdefined{org.jgrapht.graph.SimpleGraph}} \\
\hspace{4.0cm} $\bullet$ org.jgrapht.graph.SimpleWeightedGraph {\tiny \refdefined{org.jgrapht.graph.SimpleWeightedGraph}} \\
\hspace{5.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.flightplanning.SensorGraph {\tiny \refdefined{uk.ac.ed.inf.aqmaps.flightplanning.SensorGraph}} \\
\hspace{5.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.noflyzone.ObstacleGraph {\tiny \refdefined{uk.ac.ed.inf.aqmaps.noflyzone.ObstacleGraph}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.App {\tiny \refdefined{uk.ac.ed.inf.aqmaps.App}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.Drone {\tiny \refdefined{uk.ac.ed.inf.aqmaps.Drone}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.Move {\tiny \refdefined{uk.ac.ed.inf.aqmaps.Move}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.Results {\tiny \refdefined{uk.ac.ed.inf.aqmaps.Results}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.Sensor {\tiny \refdefined{uk.ac.ed.inf.aqmaps.Sensor}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.SensorMarkerFactory {\tiny \refdefined{uk.ac.ed.inf.aqmaps.SensorMarkerFactory}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.Settings {\tiny \refdefined{uk.ac.ed.inf.aqmaps.Settings}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.W3W {\tiny \refdefined{uk.ac.ed.inf.aqmaps.W3W}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer {\tiny \refdefined{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer {\tiny \refdefined{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer {\tiny \refdefined{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey {\tiny \refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue {\tiny \refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan {\tiny \refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner {\tiny \refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation {\tiny \refdefined{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.geometry.Polygon {\tiny \refdefined{uk.ac.ed.inf.aqmaps.geometry.Polygon}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.io.FileOutputController {\tiny \refdefined{uk.ac.ed.inf.aqmaps.io.FileOutputController}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.io.ServerInputController {\tiny \refdefined{uk.ac.ed.inf.aqmaps.io.ServerInputController}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.io.WebServer {\tiny \refdefined{uk.ac.ed.inf.aqmaps.io.WebServer}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder {\tiny \refdefined{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder}} \\
\hspace{1.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.noflyzone.Obstacles {\tiny \refdefined{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles}} \\
}
\section*{Interfaces}
\hspace{0.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.io.InputController {\tiny \refdefined{uk.ac.ed.inf.aqmaps.io.InputController}} \\
\hspace{0.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.io.OutputController {\tiny \refdefined{uk.ac.ed.inf.aqmaps.io.OutputController}} \\
\hspace{0.0cm} $\bullet$ uk.ac.ed.inf.aqmaps.io.Server {\tiny \refdefined{uk.ac.ed.inf.aqmaps.io.Server}} \\
}
\chapter{Package uk.ac.ed.inf.aqmaps}{
\label{uk.ac.ed.inf.aqmaps}\hypertarget{uk.ac.ed.inf.aqmaps}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\hbox{{\bf  Classes}}
\entityintro{App}{uk.ac.ed.inf.aqmaps.App}{Flies a drone around Edinburgh to collect air quality data from sensors and create a map.}
\entityintro{Drone}{uk.ac.ed.inf.aqmaps.Drone}{Represents the drone.}
\entityintro{Move}{uk.ac.ed.inf.aqmaps.Move}{A class representing a single move to be made by the drone.}
\entityintro{Results}{uk.ac.ed.inf.aqmaps.Results}{Holds and processes the calculated flightpath and collected sensor data}
\entityintro{Sensor}{uk.ac.ed.inf.aqmaps.Sensor}{A sensor with a battery level and reading.}
\entityintro{SensorMarkerFactory}{uk.ac.ed.inf.aqmaps.SensorMarkerFactory}{A factory which constructs sensor markers which displays the location, status and reading of a sensor.}
\entityintro{Settings}{uk.ac.ed.inf.aqmaps.Settings}{Holds the settings derived from the command line arguments.}
\entityintro{W3W}{uk.ac.ed.inf.aqmaps.W3W}{Holds what3words coordinate and word information.}
\vskip .1in
\vskip .1in
\section{\label{uk.ac.ed.inf.aqmaps.App}Class App}{
\hypertarget{uk.ac.ed.inf.aqmaps.App}{}\vskip .1in 
Flies a drone around Edinburgh to collect air quality data from sensors and create a map. This code follows the Google Java Style Guide at https://google.github.io/styleguide/javaguide.html\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class App
 extends java.lang.Object\end{lstlisting}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.App()}{{\bf App()}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.App.main(java.lang.String[])}{{\bf main(String\lbrack \rbrack )}} Main method\\
\end{verse}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{App()}
\hypertarget{uk.ac.ed.inf.aqmaps.App()}{{\bf  App}\\}
\begin{lstlisting}[frame=none]
public App()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{main(String\lbrack \rbrack )}
\hypertarget{uk.ac.ed.inf.aqmaps.App.main(java.lang.String[])}{{\bf  main}\\}
\begin{lstlisting}[frame=none]
public static void main(java.lang.String[] args)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Main method
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{args} -- a list of arguments in the form: day month year latitude longitude randomSeed portNumber \lbrack timeLimit\rbrack }
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.Drone}Class Drone}{
\hypertarget{uk.ac.ed.inf.aqmaps.Drone}{}\vskip .1in 
Represents the drone. Performs route planning, than follows that plan to collect sensor data.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class Drone
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Drone.input}{{\bf input}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Drone.output}{{\bf output}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Drone.settings}{{\bf settings}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Drone(uk.ac.ed.inf.aqmaps.Settings, uk.ac.ed.inf.aqmaps.io.InputController, uk.ac.ed.inf.aqmaps.io.OutputController)}{{\bf Drone(Settings, InputController, OutputController)}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Drone.flyRoute(java.util.List, uk.ac.ed.inf.aqmaps.Results)}{{\bf flyRoute(List, Results)}} Fly the drone along the route, collecting sensor data and adding it to the results.\\
\hyperlink{uk.ac.ed.inf.aqmaps.Drone.planRoute()}{{\bf planRoute()}} Plan the route that the drone will follow.\\
\hyperlink{uk.ac.ed.inf.aqmaps.Drone.start()}{{\bf start()}} Start the drone and perform route planning and data collection for the given settings.\\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{settings}
\label{uk.ac.ed.inf.aqmaps.Drone.settings}\hypertarget{uk.ac.ed.inf.aqmaps.Drone.settings}{\texttt{private final Settings\ {\bf  settings}}
}
}
\item{
\index{input}
\label{uk.ac.ed.inf.aqmaps.Drone.input}\hypertarget{uk.ac.ed.inf.aqmaps.Drone.input}{\texttt{private final io.InputController\ {\bf  input}}
}
}
\item{
\index{output}
\label{uk.ac.ed.inf.aqmaps.Drone.output}\hypertarget{uk.ac.ed.inf.aqmaps.Drone.output}{\texttt{private final io.OutputController\ {\bf  output}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Drone(Settings, InputController, OutputController)}
\hypertarget{uk.ac.ed.inf.aqmaps.Drone(uk.ac.ed.inf.aqmaps.Settings, uk.ac.ed.inf.aqmaps.io.InputController, uk.ac.ed.inf.aqmaps.io.OutputController)}{{\bf  Drone}\\}
\begin{lstlisting}[frame=none]
public Drone(Settings settings,io.InputController input,io.OutputController output)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{settings} -- the current Settings}
   \item{
\texttt{input} -- the InputController which handles data input}
   \item{
\texttt{output} -- the OutputController which handles data output}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{flyRoute(List, Results)}
\hypertarget{uk.ac.ed.inf.aqmaps.Drone.flyRoute(java.util.List, uk.ac.ed.inf.aqmaps.Results)}{{\bf  flyRoute}\\}
\begin{lstlisting}[frame=none]
private void flyRoute(java.util.List flightPlan,Results results)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Fly the drone along the route, collecting sensor data and adding it to the results.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{flightPlan} -- the flight plan for the drone to follow}
   \item{
\texttt{results} -- the Results object to record the sensor data in}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{planRoute()}
\hypertarget{uk.ac.ed.inf.aqmaps.Drone.planRoute()}{{\bf  planRoute}\\}
\begin{lstlisting}[frame=none]
private java.util.List planRoute()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Plan the route that the drone will follow.
}
\item{{\bf  Returns} -- 
a list of Moves specifying the route 
}%end item
\end{itemize}
}%end item
\item{ 
\index{start()}
\hypertarget{uk.ac.ed.inf.aqmaps.Drone.start()}{{\bf  start}\\}
\begin{lstlisting}[frame=none]
public void start()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Start the drone and perform route planning and data collection for the given settings.
}
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.Move}Class Move}{
\hypertarget{uk.ac.ed.inf.aqmaps.Move}{}\vskip .1in 
A class representing a single move to be made by the drone.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class Move
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Move.after}{{\bf after}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Move.before}{{\bf before}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Move.direction}{{\bf direction}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Move.sensorW3W}{{\bf sensorW3W}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Move(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords, int, uk.ac.ed.inf.aqmaps.W3W)}{{\bf Move(Coords, Coords, int, W3W)}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Move.getAfter()}{{\bf getAfter()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Move.getBefore()}{{\bf getBefore()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Move.getDirection()}{{\bf getDirection()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Move.getSensorW3W()}{{\bf getSensorW3W()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Move.toString()}{{\bf toString()}} \\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{before}
\label{uk.ac.ed.inf.aqmaps.Move.before}\hypertarget{uk.ac.ed.inf.aqmaps.Move.before}{\texttt{private final geometry.Coords\ {\bf  before}}
}
}
\item{
\index{after}
\label{uk.ac.ed.inf.aqmaps.Move.after}\hypertarget{uk.ac.ed.inf.aqmaps.Move.after}{\texttt{private final geometry.Coords\ {\bf  after}}
}
}
\item{
\index{direction}
\label{uk.ac.ed.inf.aqmaps.Move.direction}\hypertarget{uk.ac.ed.inf.aqmaps.Move.direction}{\texttt{private final int\ {\bf  direction}}
}
}
\item{
\index{sensorW3W}
\label{uk.ac.ed.inf.aqmaps.Move.sensorW3W}\hypertarget{uk.ac.ed.inf.aqmaps.Move.sensorW3W}{\texttt{private final W3W\ {\bf  sensorW3W}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Move(Coords, Coords, int, W3W)}
\hypertarget{uk.ac.ed.inf.aqmaps.Move(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords, int, uk.ac.ed.inf.aqmaps.W3W)}{{\bf  Move}\\}
\begin{lstlisting}[frame=none]
public Move(geometry.Coords before,geometry.Coords after,int direction,W3W sensorW3W)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{before} -- the position of the drone before the move}
   \item{
\texttt{after} -- the position of the drone after the move}
   \item{
\texttt{direction} -- the direction of the move in degrees, from 0 to 350 anticlockwise starting from east}
   \item{
\texttt{sensorW3W} -- the location of the sensor visited by the drone at the end of this move, or null if no sensor is visited}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getAfter()}
\hypertarget{uk.ac.ed.inf.aqmaps.Move.getAfter()}{{\bf  getAfter}\\}
\begin{lstlisting}[frame=none]
public geometry.Coords getAfter()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the position of the drone after making the move 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getBefore()}
\hypertarget{uk.ac.ed.inf.aqmaps.Move.getBefore()}{{\bf  getBefore}\\}
\begin{lstlisting}[frame=none]
public geometry.Coords getBefore()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the position of the drone before making the move 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getDirection()}
\hypertarget{uk.ac.ed.inf.aqmaps.Move.getDirection()}{{\bf  getDirection}\\}
\begin{lstlisting}[frame=none]
public int getDirection()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the direction of move in degrees 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSensorW3W()}
\hypertarget{uk.ac.ed.inf.aqmaps.Move.getSensorW3W()}{{\bf  getSensorW3W}\\}
\begin{lstlisting}[frame=none]
public W3W getSensorW3W()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the W3W of the sensor that this move reaches, or null if it does not reach a sensor 
}%end item
\end{itemize}
}%end item
\item{ 
\index{toString()}
\hypertarget{uk.ac.ed.inf.aqmaps.Move.toString()}{{\bf  toString}\\}
\begin{lstlisting}[frame=none]
public java.lang.String toString()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.Results}Class Results}{
\hypertarget{uk.ac.ed.inf.aqmaps.Results}{}\vskip .1in 
Holds and processes the calculated flightpath and collected sensor data\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class Results
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Results.flightpath}{{\bf flightpath}} The planned flightpath of the drone as a list of Moves\\
\hyperlink{uk.ac.ed.inf.aqmaps.Results.sensorsVisited}{{\bf sensorsVisited}} A map from W3W sensor locations to their corresponding Sensor data.\\
\hyperlink{uk.ac.ed.inf.aqmaps.Results.sensorW3Ws}{{\bf sensorW3Ws}} A list of the W3W of the sensors that are planned to be visited.\\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Results(java.util.List)}{{\bf Results(List)}} Constructor\\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Results.createFlightpathLineString()}{{\bf createFlightpathLineString()}} Creates a GeoJSON LineString which shows the path that shows the path taken by the drone.\\
\hyperlink{uk.ac.ed.inf.aqmaps.Results.createSensorMarkers()}{{\bf createSensorMarkers()}} Creates Features containing Points which mark the position and reading/status of the sensors.\\
\hyperlink{uk.ac.ed.inf.aqmaps.Results.getFlightpathString()}{{\bf getFlightpathString()}} Gets a flightpath String of the following format: 1,\lbrack startLng\rbrack ,\lbrack startLat\rbrack ,\lbrack angle\rbrack ,\lbrack endLng\rbrack ,\lbrack endLat\rbrack ,\lbrack sensor w3w or null\rbrack \textbackslash n 2,\lbrack startLng\rbrack ,\lbrack startLat\rbrack ,\lbrack angle\rbrack ,\lbrack endLng\rbrack ,\lbrack endLat\rbrack ,\lbrack sensor w3w or null\rbrack \textbackslash n ...\\
\hyperlink{uk.ac.ed.inf.aqmaps.Results.getMapGeoJSON()}{{\bf getMapGeoJSON()}} Creates a GeoJSON string of a map which displays the flightpath of the drone and markers displaying the readings or status of the sensors.\\
\hyperlink{uk.ac.ed.inf.aqmaps.Results.recordFlightpath(java.util.List)}{{\bf recordFlightpath(List)}} Adds a calculated flight to the results\\
\hyperlink{uk.ac.ed.inf.aqmaps.Results.recordSensorReading(uk.ac.ed.inf.aqmaps.Sensor)}{{\bf recordSensorReading(Sensor)}} Add a sensor with its readings to the results\\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{sensorsVisited}
\label{uk.ac.ed.inf.aqmaps.Results.sensorsVisited}\hypertarget{uk.ac.ed.inf.aqmaps.Results.sensorsVisited}{\texttt{private final java.util.Map\ {\bf  sensorsVisited}}
}
\begin{itemize}
\item{\vskip -.9ex 
A map from W3W sensor locations to their corresponding Sensor data.}
\end{itemize}
}
\item{
\index{sensorW3Ws}
\label{uk.ac.ed.inf.aqmaps.Results.sensorW3Ws}\hypertarget{uk.ac.ed.inf.aqmaps.Results.sensorW3Ws}{\texttt{private final java.util.List\ {\bf  sensorW3Ws}}
}
\begin{itemize}
\item{\vskip -.9ex 
A list of the W3W of the sensors that are planned to be visited.}
\end{itemize}
}
\item{
\index{flightpath}
\label{uk.ac.ed.inf.aqmaps.Results.flightpath}\hypertarget{uk.ac.ed.inf.aqmaps.Results.flightpath}{\texttt{private java.util.List\ {\bf  flightpath}}
}
\begin{itemize}
\item{\vskip -.9ex 
The planned flightpath of the drone as a list of Moves}
\end{itemize}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Results(List)}
\hypertarget{uk.ac.ed.inf.aqmaps.Results(java.util.List)}{{\bf  Results}\\}
\begin{lstlisting}[frame=none]
public Results(java.util.List sensorW3Ws)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Constructor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{sensorW3Ws} -- a list of sensor locations as W3W that the drone is visiting}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{createFlightpathLineString()}
\hypertarget{uk.ac.ed.inf.aqmaps.Results.createFlightpathLineString()}{{\bf  createFlightpathLineString}\\}
\begin{lstlisting}[frame=none]
private com.mapbox.geojson.Feature createFlightpathLineString()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Creates a GeoJSON LineString which shows the path that shows the path taken by the drone.
}
\item{{\bf  Returns} -- 
a Feature containing the LineString 
}%end item
\end{itemize}
}%end item
\item{ 
\index{createSensorMarkers()}
\hypertarget{uk.ac.ed.inf.aqmaps.Results.createSensorMarkers()}{{\bf  createSensorMarkers}\\}
\begin{lstlisting}[frame=none]
private java.util.List createSensorMarkers()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Creates Features containing Points which mark the position and reading/status of the sensors.
}
\item{{\bf  Returns} -- 
a List of Features 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getFlightpathString()}
\hypertarget{uk.ac.ed.inf.aqmaps.Results.getFlightpathString()}{{\bf  getFlightpathString}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getFlightpathString()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Gets a flightpath String of the following format: 1,\lbrack startLng\rbrack ,\lbrack startLat\rbrack ,\lbrack angle\rbrack ,\lbrack endLng\rbrack ,\lbrack endLat\rbrack ,\lbrack sensor w3w or null\rbrack \textbackslash n 2,\lbrack startLng\rbrack ,\lbrack startLat\rbrack ,\lbrack angle\rbrack ,\lbrack endLng\rbrack ,\lbrack endLat\rbrack ,\lbrack sensor w3w or null\rbrack \textbackslash n ...
}
\item{{\bf  Returns} -- 
the flightpath String 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getMapGeoJSON()}
\hypertarget{uk.ac.ed.inf.aqmaps.Results.getMapGeoJSON()}{{\bf  getMapGeoJSON}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getMapGeoJSON()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Creates a GeoJSON string of a map which displays the flightpath of the drone and markers displaying the readings or status of the sensors.
}
\item{{\bf  Returns} -- 
a String of the GeoJSON 
}%end item
\end{itemize}
}%end item
\item{ 
\index{recordFlightpath(List)}
\hypertarget{uk.ac.ed.inf.aqmaps.Results.recordFlightpath(java.util.List)}{{\bf  recordFlightpath}\\}
\begin{lstlisting}[frame=none]
public void recordFlightpath(java.util.List flightpath)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Adds a calculated flight to the results
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{flightpath} -- a list of Moves representing the flightpath}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{recordSensorReading(Sensor)}
\hypertarget{uk.ac.ed.inf.aqmaps.Results.recordSensorReading(uk.ac.ed.inf.aqmaps.Sensor)}{{\bf  recordSensorReading}\\}
\begin{lstlisting}[frame=none]
public void recordSensorReading(Sensor sensor)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Add a sensor with its readings to the results
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{sensor} -- the Sensor}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.Sensor}Class Sensor}{
\hypertarget{uk.ac.ed.inf.aqmaps.Sensor}{}\vskip .1in 
A sensor with a battery level and reading.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class Sensor
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Sensor.battery}{{\bf battery}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Sensor.location}{{\bf location}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Sensor.reading}{{\bf reading}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Sensor(uk.ac.ed.inf.aqmaps.W3W, float, java.lang.String)}{{\bf Sensor(W3W, float, String)}} Constructor\\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Sensor.getBattery()}{{\bf getBattery()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Sensor.getLocation()}{{\bf getLocation()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Sensor.getReading()}{{\bf getReading()}} \\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{location}
\label{uk.ac.ed.inf.aqmaps.Sensor.location}\hypertarget{uk.ac.ed.inf.aqmaps.Sensor.location}{\texttt{private final W3W\ {\bf  location}}
}
}
\item{
\index{battery}
\label{uk.ac.ed.inf.aqmaps.Sensor.battery}\hypertarget{uk.ac.ed.inf.aqmaps.Sensor.battery}{\texttt{private final float\ {\bf  battery}}
}
}
\item{
\index{reading}
\label{uk.ac.ed.inf.aqmaps.Sensor.reading}\hypertarget{uk.ac.ed.inf.aqmaps.Sensor.reading}{\texttt{private final java.lang.String\ {\bf  reading}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Sensor(W3W, float, String)}
\hypertarget{uk.ac.ed.inf.aqmaps.Sensor(uk.ac.ed.inf.aqmaps.W3W, float, java.lang.String)}{{\bf  Sensor}\\}
\begin{lstlisting}[frame=none]
public Sensor(W3W w3wLocation,float battery,java.lang.String reading)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Constructor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{w3wLocation} -- the W3W location of the sensor}
   \item{
\texttt{battery} -- the current battery level of the sensor, as a percentage}
   \item{
\texttt{reading} -- the reading of the sensor as a String}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getBattery()}
\hypertarget{uk.ac.ed.inf.aqmaps.Sensor.getBattery()}{{\bf  getBattery}\\}
\begin{lstlisting}[frame=none]
public float getBattery()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the battery level of this sensor as a percentage 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLocation()}
\hypertarget{uk.ac.ed.inf.aqmaps.Sensor.getLocation()}{{\bf  getLocation}\\}
\begin{lstlisting}[frame=none]
public W3W getLocation()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the W3W location of this sensor 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getReading()}
\hypertarget{uk.ac.ed.inf.aqmaps.Sensor.getReading()}{{\bf  getReading}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getReading()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the reading of the sensor, as a String. If the battery level is 10\%\ or greater this should contain a float value, but if it is less than 10\%\ the reading cannot be trusted and may be incorrect, null or NaN. 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.SensorMarkerFactory}Class SensorMarkerFactory}{
\hypertarget{uk.ac.ed.inf.aqmaps.SensorMarkerFactory}{}\vskip .1in 
A factory which constructs sensor markers which displays the location, status and reading of a sensor. This factory does not produce hypothetical SensorMarker instances, but Feature instances instead, since Feature cannot be subclassed due to its lack of a public constructor.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class SensorMarkerFactory
 extends java.lang.Object\end{lstlisting}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.SensorMarkerFactory()}{{\bf SensorMarkerFactory()}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.SensorMarkerFactory.createPoint(uk.ac.ed.inf.aqmaps.W3W, java.lang.String)}{{\bf createPoint(W3W, String)}} Create a Feature containing a Point marker with a position, colour, and no marker symbol.\\
\hyperlink{uk.ac.ed.inf.aqmaps.SensorMarkerFactory.createPoint(uk.ac.ed.inf.aqmaps.W3W, java.lang.String, java.lang.String)}{{\bf createPoint(W3W, String, String)}} Create a Feature with a position, colour, and marker symbol.\\
\hyperlink{uk.ac.ed.inf.aqmaps.SensorMarkerFactory.getMarkerSymbol(double)}{{\bf getMarkerSymbol(double)}} Gets the marker symbol string for the given pollution level\\
\hyperlink{uk.ac.ed.inf.aqmaps.SensorMarkerFactory.getRgbString(double)}{{\bf getRgbString(double)}} Converts a pollution level to a corresponding RGB string.\\
\hyperlink{uk.ac.ed.inf.aqmaps.SensorMarkerFactory.getSensorMarker(uk.ac.ed.inf.aqmaps.W3W, uk.ac.ed.inf.aqmaps.Sensor)}{{\bf getSensorMarker(W3W, Sensor)}} Creates a marker located at the position of this sensor.\\
\end{verse}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{SensorMarkerFactory()}
\hypertarget{uk.ac.ed.inf.aqmaps.SensorMarkerFactory()}{{\bf  SensorMarkerFactory}\\}
\begin{lstlisting}[frame=none]
public SensorMarkerFactory()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{createPoint(W3W, String)}
\hypertarget{uk.ac.ed.inf.aqmaps.SensorMarkerFactory.createPoint(uk.ac.ed.inf.aqmaps.W3W, java.lang.String)}{{\bf  createPoint}\\}
\begin{lstlisting}[frame=none]
private com.mapbox.geojson.Feature createPoint(W3W w3w,java.lang.String rgbString)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Create a Feature containing a Point marker with a position, colour, and no marker symbol.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{w3w} -- the W3W location of the sensor}
   \item{
\texttt{rgbString} -- the RGB colour string of the point}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a Feature containing a Point 
}%end item
\end{itemize}
}%end item
\item{ 
\index{createPoint(W3W, String, String)}
\hypertarget{uk.ac.ed.inf.aqmaps.SensorMarkerFactory.createPoint(uk.ac.ed.inf.aqmaps.W3W, java.lang.String, java.lang.String)}{{\bf  createPoint}\\}
\begin{lstlisting}[frame=none]
private com.mapbox.geojson.Feature createPoint(W3W w3w,java.lang.String rgbString,java.lang.String markerSymbol)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Create a Feature with a position, colour, and marker symbol.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{w3w} -- the W3W location of the sensor}
   \item{
\texttt{rgbString} -- the RGB colour string of the point}
   \item{
\texttt{markerSymbol} -- the marker symbol string}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a Feature containing a Point 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getMarkerSymbol(double)}
\hypertarget{uk.ac.ed.inf.aqmaps.SensorMarkerFactory.getMarkerSymbol(double)}{{\bf  getMarkerSymbol}\\}
\begin{lstlisting}[frame=none]
private java.lang.String getMarkerSymbol(double pollutionLevel)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Gets the marker symbol string for the given pollution level
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{pollutionLevel} -- the pollution level as a double between 0 and 256}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a String describing the marker symbol 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getRgbString(double)}
\hypertarget{uk.ac.ed.inf.aqmaps.SensorMarkerFactory.getRgbString(double)}{{\bf  getRgbString}\\}
\begin{lstlisting}[frame=none]
private java.lang.String getRgbString(double pollutionLevel)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Converts a pollution level to a corresponding RGB string.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{pollutionLevel} -- the pollution level as a double between 0 and 256}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the rgb string \#xxxxxx of the colour representing the pollution level 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSensorMarker(W3W, Sensor)}
\hypertarget{uk.ac.ed.inf.aqmaps.SensorMarkerFactory.getSensorMarker(uk.ac.ed.inf.aqmaps.W3W, uk.ac.ed.inf.aqmaps.Sensor)}{{\bf  getSensorMarker}\\}
\begin{lstlisting}[frame=none]
public com.mapbox.geojson.Feature getSensorMarker(W3W w3w,Sensor sensor)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Creates a marker located at the position of this sensor. If a sensor reading was taken successfully the marker is coloured and assigned a symbol based on the reading, and if it has low battery or was not visited, assigns different symbols.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{w3w} -- the location of the sensor as a W3W}
   \item{
\texttt{sensor} -- the Sensor containing the sensor data, or null if the sensor was not visited}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a Feature containing a Point and various attributes describing the marker 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.Settings}Class Settings}{
\hypertarget{uk.ac.ed.inf.aqmaps.Settings}{}\vskip .1in 
Holds the settings derived from the command line arguments.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class Settings
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.day}{{\bf day}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.DEFAULT_TIME_LIMIT_SECONDS}{{\bf DEFAULT\_TIME\_LIMIT\_SECONDS}} The default value in seconds of the time limit on the flight planning algorithm, to be used when a time limit has not been received as an argument.\\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.maxRunTime}{{\bf maxRunTime}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.month}{{\bf month}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.port}{{\bf port}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.randomSeed}{{\bf randomSeed}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.startCoords}{{\bf startCoords}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.year}{{\bf year}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Settings(java.lang.String[])}{{\bf Settings(String\lbrack \rbrack )}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.getDay()}{{\bf getDay()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.getMaxRunTime()}{{\bf getMaxRunTime()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.getMonth()}{{\bf getMonth()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.getPort()}{{\bf getPort()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.getRandomSeed()}{{\bf getRandomSeed()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.getStartCoords()}{{\bf getStartCoords()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.Settings.getYear()}{{\bf getYear()}} \\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{DEFAULT\_TIME\_LIMIT\_SECONDS}
\label{uk.ac.ed.inf.aqmaps.Settings.DEFAULT_TIME_LIMIT_SECONDS}\hypertarget{uk.ac.ed.inf.aqmaps.Settings.DEFAULT_TIME_LIMIT_SECONDS}{\texttt{private static final double\ {\bf  DEFAULT\_TIME\_LIMIT\_SECONDS}}
}
\begin{itemize}
\item{\vskip -.9ex 
The default value in seconds of the time limit on the flight planning algorithm, to be used when a time limit has not been received as an argument. Increasing this has highly diminishing returns. See \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner}{FlightPlanner}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner}}. Default set to 0 for random repeatability.}
\end{itemize}
}
\item{
\index{day}
\label{uk.ac.ed.inf.aqmaps.Settings.day}\hypertarget{uk.ac.ed.inf.aqmaps.Settings.day}{\texttt{private final int\ {\bf  day}}
}
}
\item{
\index{month}
\label{uk.ac.ed.inf.aqmaps.Settings.month}\hypertarget{uk.ac.ed.inf.aqmaps.Settings.month}{\texttt{private final int\ {\bf  month}}
}
}
\item{
\index{year}
\label{uk.ac.ed.inf.aqmaps.Settings.year}\hypertarget{uk.ac.ed.inf.aqmaps.Settings.year}{\texttt{private final int\ {\bf  year}}
}
}
\item{
\index{startCoords}
\label{uk.ac.ed.inf.aqmaps.Settings.startCoords}\hypertarget{uk.ac.ed.inf.aqmaps.Settings.startCoords}{\texttt{private final geometry.Coords\ {\bf  startCoords}}
}
}
\item{
\index{randomSeed}
\label{uk.ac.ed.inf.aqmaps.Settings.randomSeed}\hypertarget{uk.ac.ed.inf.aqmaps.Settings.randomSeed}{\texttt{private final int\ {\bf  randomSeed}}
}
}
\item{
\index{port}
\label{uk.ac.ed.inf.aqmaps.Settings.port}\hypertarget{uk.ac.ed.inf.aqmaps.Settings.port}{\texttt{private final int\ {\bf  port}}
}
}
\item{
\index{maxRunTime}
\label{uk.ac.ed.inf.aqmaps.Settings.maxRunTime}\hypertarget{uk.ac.ed.inf.aqmaps.Settings.maxRunTime}{\texttt{private final double\ {\bf  maxRunTime}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Settings(String\lbrack \rbrack )}
\hypertarget{uk.ac.ed.inf.aqmaps.Settings(java.lang.String[])}{{\bf  Settings}\\}
\begin{lstlisting}[frame=none]
public Settings(java.lang.String[] args)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{args} -- the input command line args}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getDay()}
\hypertarget{uk.ac.ed.inf.aqmaps.Settings.getDay()}{{\bf  getDay}\\}
\begin{lstlisting}[frame=none]
public int getDay()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the day to generate the map for 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getMaxRunTime()}
\hypertarget{uk.ac.ed.inf.aqmaps.Settings.getMaxRunTime()}{{\bf  getMaxRunTime}\\}
\begin{lstlisting}[frame=none]
public double getMaxRunTime()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the maximum run time of the flight planner in seconds 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getMonth()}
\hypertarget{uk.ac.ed.inf.aqmaps.Settings.getMonth()}{{\bf  getMonth}\\}
\begin{lstlisting}[frame=none]
public int getMonth()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the month to generate the map for 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getPort()}
\hypertarget{uk.ac.ed.inf.aqmaps.Settings.getPort()}{{\bf  getPort}\\}
\begin{lstlisting}[frame=none]
public int getPort()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the port number of the server 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getRandomSeed()}
\hypertarget{uk.ac.ed.inf.aqmaps.Settings.getRandomSeed()}{{\bf  getRandomSeed}\\}
\begin{lstlisting}[frame=none]
public int getRandomSeed()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the random seed to use in the algorithms 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getStartCoords()}
\hypertarget{uk.ac.ed.inf.aqmaps.Settings.getStartCoords()}{{\bf  getStartCoords}\\}
\begin{lstlisting}[frame=none]
public geometry.Coords getStartCoords()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the starting coordinates of the drone 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getYear()}
\hypertarget{uk.ac.ed.inf.aqmaps.Settings.getYear()}{{\bf  getYear}\\}
\begin{lstlisting}[frame=none]
public int getYear()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the year to generate the map for 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.W3W}Class W3W}{
\hypertarget{uk.ac.ed.inf.aqmaps.W3W}{}\vskip .1in 
Holds what3words coordinate and word information.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class W3W
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.W3W.coordinates}{{\bf coordinates}} The coordinates of the centre of the W3W square\\
\hyperlink{uk.ac.ed.inf.aqmaps.W3W.words}{{\bf words}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.W3W(uk.ac.ed.inf.aqmaps.geometry.Coords, java.lang.String)}{{\bf W3W(Coords, String)}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.W3W.getCoordinates()}{{\bf getCoordinates()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.W3W.getWords()}{{\bf getWords()}} \\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{coordinates}
\label{uk.ac.ed.inf.aqmaps.W3W.coordinates}\hypertarget{uk.ac.ed.inf.aqmaps.W3W.coordinates}{\texttt{private final geometry.Coords\ {\bf  coordinates}}
}
\begin{itemize}
\item{\vskip -.9ex 
The coordinates of the centre of the W3W square}
\end{itemize}
}
\item{
\index{words}
\label{uk.ac.ed.inf.aqmaps.W3W.words}\hypertarget{uk.ac.ed.inf.aqmaps.W3W.words}{\texttt{private final java.lang.String\ {\bf  words}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{W3W(Coords, String)}
\hypertarget{uk.ac.ed.inf.aqmaps.W3W(uk.ac.ed.inf.aqmaps.geometry.Coords, java.lang.String)}{{\bf  W3W}\\}
\begin{lstlisting}[frame=none]
public W3W(geometry.Coords coordinates,java.lang.String words)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{coordinates} -- the coordinates of the centre of the W3W square}
   \item{
\texttt{words} -- the 3 words}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getCoordinates()}
\hypertarget{uk.ac.ed.inf.aqmaps.W3W.getCoordinates()}{{\bf  getCoordinates}\\}
\begin{lstlisting}[frame=none]
public geometry.Coords getCoordinates()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the coordinates of the centre of the W3W square 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getWords()}
\hypertarget{uk.ac.ed.inf.aqmaps.W3W.getWords()}{{\bf  getWords}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getWords()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
words the 3 words 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
}
\chapter{Package uk.ac.ed.inf.aqmaps.flightplanning}{
\label{uk.ac.ed.inf.aqmaps.flightplanning}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\hbox{{\bf  Classes}}
\entityintro{EnhancedTwoOptTSP}{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP}{A modified version of TwoOptHeuristicTSP from JGraphT which is used to compute tours which visit all sensors and returns to the starting point.}
\entityintro{FlightCacheKey}{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey}{A class which holds data about the input values of the flight planning algorithm from a position to a sensor, potentially with a next sensor.}
\entityintro{FlightCacheValue}{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue}{A class which holds data about the output values of the flight planning algorithm from a position to a sensor, potentially with a next sensor.}
\entityintro{FlightPlan}{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan}{A wrapper class for a flight plan as a list of moves, and the random seed that was used to generate it.}
\entityintro{FlightPlanner}{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner}{Handles the creation of a flight plan for the drone.}
\entityintro{SensorGraph}{uk.ac.ed.inf.aqmaps.flightplanning.SensorGraph}{A graph of the sensors and their distances to each other, taking into account obstacle evasion.}
\entityintro{WaypointNavigation}{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation}{A class which handles the navigation of the drone along a series of waypoints to a target.}
\vskip .1in
\vskip .1in
\section{\label{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP}Class EnhancedTwoOptTSP}{
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP}{}\vskip .1in 
A modified version of TwoOptHeuristicTSP from JGraphT which is used to compute tours which visit all sensors and returns to the starting point. Source code of TwoOptHeuristicTSP can be found \hyperref{https://github.com/jgrapht/jgrapht/blob/master/jgrapht-core/src/main/java/org/jgrapht/alg/tour/TwoOptHeuristicTSP.java}{}{}{here (GitHub)}.

\hyperref{https://jgrapht.org/}{}{}{JGraphT main website}, \hyperref{https://github.com/jgrapht/jgrapht}{}{}{GitHub source}, accessed 30/11/2020

The following JavaDoc is unchanged from the the original:

The 2-opt heuristic algorithm for the TSP problem.

The travelling salesman problem (TSP) asks the following question: "Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city?".

This is an implementation of the 2-opt improvement heuristic algorithm. The algorithm generates \textit{ passes} initial tours and then iteratively improves the tours until a local minimum is reached. In each iteration it applies the best possible 2-opt move which means to find the best pair of edges \$(i,i+1)\$\ and \$(j,j+1)\$\ such that replacing them with \$(i,j)\$\ and \$(i+1,j+1)\$\ minimizes the tour length. The default initial tours use RandomTour, however an alternative algorithm can be provided to create the initial tour. Initial tours generated using NearestNeighborHeuristicTSP give good results and performance.

See \hyperref{https://en.wikipedia.org/wiki/2-opt}{}{}{wikipedia} for more details.

This implementation can also be used in order to try to improve an existing tour. See method \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.improveTour(org.jgrapht.GraphPath)}{improveTour(GraphPath)}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.improveTour(org.jgrapht.GraphPath)}}\}.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class EnhancedTwoOptTSP
 extends org.jgrapht.alg.tour.TwoOptHeuristicTSP\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.flightPlanner}{{\bf flightPlanner}} The FlightPlanner for computing tour weights\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.graph}{{\bf graph}} A graph representation of the sensors\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.index}{{\bf index}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.n}{{\bf n}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.revIndex}{{\bf revIndex}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.start}{{\bf start}} The start and end position of the drone\\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP(int, int, uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner)}{{\bf EnhancedTwoOptTSP(int, int, Coords, FlightPlanner)}} Constructor\\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.applyMove(int[], int[], int, int)}{{\bf applyMove(int\lbrack \rbrack , int\lbrack \rbrack , int, int)}} This code is part of the original library's improve(), but it is extracted into a method to avoid duplication as this class uses it in more than one place.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.getDirectLength(java.util.List)}{{\bf getDirectLength(List)}} (New method, not in the library).\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.getTour(org.jgrapht.Graph)}{{\bf getTour(Graph)}} Computes a tour by first using JGraphT's TwoOptHeuristicTSP (the superclass of this) to find a short tour using the edge weights in the provided graph, which are straight line (obstacle avoiding) distance measures.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.getTourAsList(int[])}{{\bf getTourAsList(int\lbrack \rbrack )}} New method, not in the library.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.improve(int[])}{{\bf improve(int\lbrack \rbrack )}} A modified version of the improve() method in the library.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.improveTour(org.jgrapht.GraphPath)}{{\bf improveTour(GraphPath)}} (Code unchanged from library code other than type parameters)\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.init(org.jgrapht.Graph)}{{\bf init(Graph)}} (Reduced version of library code as we aren't using dist\lbrack \rbrack \lbrack \rbrack )\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.pathToTour(org.jgrapht.GraphPath)}{{\bf pathToTour(GraphPath)}} (Code and Javadoc unchanged from library other than type parameters)\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.tourToPath(int[])}{{\bf tourToPath(int\lbrack \rbrack )}} (Code and Javadoc unchanged from library other than type parameters)\\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{start}
\label{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.start}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.start}{\texttt{private final uk.ac.ed.inf.aqmaps.geometry.Coords\ {\bf  start}}
}
\begin{itemize}
\item{\vskip -.9ex 
The start and end position of the drone}
\end{itemize}
}
\item{
\index{flightPlanner}
\label{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.flightPlanner}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.flightPlanner}{\texttt{private final FlightPlanner\ {\bf  flightPlanner}}
}
\begin{itemize}
\item{\vskip -.9ex 
The FlightPlanner for computing tour weights}
\end{itemize}
}
\item{
\index{graph}
\label{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.graph}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.graph}{\texttt{private org.jgrapht.Graph\ {\bf  graph}}
}
\begin{itemize}
\item{\vskip -.9ex 
A graph representation of the sensors}
\end{itemize}
}
\item{
\index{n}
\label{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.n}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.n}{\texttt{private int\ {\bf  n}}
}
}
\item{
\index{index}
\label{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.index}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.index}{\texttt{private java.util.Map\ {\bf  index}}
}
}
\item{
\index{revIndex}
\label{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.revIndex}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.revIndex}{\texttt{private java.util.Map\ {\bf  revIndex}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{EnhancedTwoOptTSP(int, int, Coords, FlightPlanner)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP(int, int, uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner)}{{\bf  EnhancedTwoOptTSP}\\}
\begin{lstlisting}[frame=none]
public EnhancedTwoOptTSP(int passes,int seed,uk.ac.ed.inf.aqmaps.geometry.Coords start,FlightPlanner flightPlanner)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Constructor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{passes} -- how many initial random tours to check when running 2-opt}
   \item{
\texttt{seed} -- the random seed}
   \item{
\texttt{start} -- the start position of the drone}
   \item{
\texttt{flightPlanner} -- the FlightPlanner to use for the second 2-opt pass to compute tour weights as the number of moves needed by the drone}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{applyMove(int\lbrack \rbrack , int\lbrack \rbrack , int, int)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.applyMove(int[], int[], int, int)}{{\bf  applyMove}\\}
\begin{lstlisting}[frame=none]
private void applyMove(int[] tour,int[] newTour,int i,int j)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

This code is part of the original library's improve(), but it is extracted into a method to avoid duplication as this class uses it in more than one place.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{tour} -- the tour to apply the move to}
   \item{
\texttt{newTour} -- the new tour with the move applied}
   \item{
\texttt{i} -- the first swap point}
   \item{
\texttt{j} -- the second swap point}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{getDirectLength(List)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.getDirectLength(java.util.List)}{{\bf  getDirectLength}\\}
\begin{lstlisting}[frame=none]
private double getDirectLength(java.util.List tourList)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

(New method, not in the library). Computes the length of tour using the direct real distance between the vertices.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{tourList} -- the tour as a list of Coords}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the length of the tour in degrees, using euclidean distance (not using the flight planner) 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getTour(Graph)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.getTour(org.jgrapht.Graph)}{{\bf  getTour}\\}
\begin{lstlisting}[frame=none]
public org.jgrapht.GraphPath getTour(org.jgrapht.Graph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Computes a tour by first using JGraphT's TwoOptHeuristicTSP (the superclass of this) to find a short tour using the edge weights in the provided graph, which are straight line (obstacle avoiding) distance measures. Then, it runs a second pass of 2-opt to further improve upon the tour by instead using a FlightPlanner to generate the actual drone moves along the tour and using the number of moves as the weight of a tour.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- the input sensor graph containing the start location and the sensors, and edge weights of the shortest path between two points which avoids obstacles.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the tour as a GraphPath 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getTourAsList(int\lbrack \rbrack )}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.getTourAsList(int[])}{{\bf  getTourAsList}\\}
\begin{lstlisting}[frame=none]
private java.util.List getTourAsList(int[] tour)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

New method, not in the library. Converts a tour as an array to the corresponding list of Coords.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{tour} -- a tour as an int\lbrack \rbrack }
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a List of Coords 
}%end item
\end{itemize}
}%end item
\item{ 
\index{improve(int\lbrack \rbrack )}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.improve(int[])}{{\bf  improve}\\}
\begin{lstlisting}[frame=none]
private int[] improve(int[] tour)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

A modified version of the improve() method in the library. The main difference is that this version does not have a distance matrix due to the fact that the distance between a pair of sensors depends heavily on the rest of the tour that it is in. Instead of calculating the distance change with

\texttt{\small double change = dist\lbrack ci\rbrack \lbrack cj\rbrack\ + dist\lbrack ci1\rbrack \lbrack cj1\rbrack\ - dist\lbrack ci\rbrack \lbrack ci1\rbrack\ - dist\lbrack cj\rbrack \lbrack cj1\rbrack ;}

we instead use the FlightPlanner to plan a route along the tour, and compare its length to the unmodified tour. Since the tours being improved by this algorithm have already been through 2-opt with direct distance measures, drastic changes to the tour are unlikely to improve it, and are also computationally expensive since they are longer and may collide with more buildings and so on. To avoid this, only tours which are close in distance to the original will be tried.

Original JGraphT JavaDoc:

Improve the tour using the 2-opt heuristic. In each iteration it applies the best possible 2-opt move which means to find the best pair of edges \$(i,i+1)\$\ and \$(j,j+1)\$\ such that replacing them with \$(i,j)\$\ and \$(i+1,j+1)\$\ minimizes the tour length.

The returned array instance might or might not be the input array.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{tour} -- the input tour}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a possibly improved tour 
}%end item
\end{itemize}
}%end item
\item{ 
\index{improveTour(GraphPath)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.improveTour(org.jgrapht.GraphPath)}{{\bf  improveTour}\\}
\begin{lstlisting}[frame=none]
public org.jgrapht.GraphPath improveTour(org.jgrapht.GraphPath graphPath)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

(Code unchanged from library code other than type parameters)

Try to improve a tour by running the 2-opt heuristic using the FlightPlanner to measure the length of tours.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graphPath} -- a tour}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a possibly improved tour 
}%end item
\end{itemize}
}%end item
\item{ 
\index{init(Graph)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.init(org.jgrapht.Graph)}{{\bf  init}\\}
\begin{lstlisting}[frame=none]
private void init(org.jgrapht.Graph graph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

(Reduced version of library code as we aren't using dist\lbrack \rbrack \lbrack \rbrack )

Initialize graph and mapping to integer vertices.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- the input graph}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{pathToTour(GraphPath)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.pathToTour(org.jgrapht.GraphPath)}{{\bf  pathToTour}\\}
\begin{lstlisting}[frame=none]
private int[] pathToTour(org.jgrapht.GraphPath path)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

(Code and Javadoc unchanged from library other than type parameters)

Transform from a path representation to an array representation.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{path} -- graph path}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
an array containing the index of the vertices of the tour 
}%end item
\end{itemize}
}%end item
\item{ 
\index{tourToPath(int\lbrack \rbrack )}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP.tourToPath(int[])}{{\bf  tourToPath}\\}
\begin{lstlisting}[frame=none]
private org.jgrapht.GraphPath tourToPath(int[] tour)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

(Code and Javadoc unchanged from library other than type parameters)

Transform from an array representation to a graph path.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{tour} -- an array containing the index of the vertices of the tour}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a graph path 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Members inherited from class TwoOptHeuristicTSP }{
\texttt{org.jgrapht.alg.tour.TwoOptHeuristicTSP} {\small 
\refdefined{org.jgrapht.alg.tour.TwoOptHeuristicTSP}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{private int {\bf  createInitialTour}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  dist}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public GraphPath {\bf  getTour}(\texttt{org.jgrapht.Graph} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  graph}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private int {\bf  improve}(\texttt{int\lbrack \rbrack } {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public GraphPath {\bf  improveTour}(\texttt{org.jgrapht.GraphPath} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  index}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private void {\bf  init}(\texttt{org.jgrapht.Graph} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private final {\bf  initializer}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private final {\bf  minCostImprovement}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  n}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private final {\bf  passes}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private int {\bf  pathToTour}(\texttt{org.jgrapht.GraphPath} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  revIndex}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private GraphPath {\bf  tourToPath}(\texttt{int\lbrack \rbrack } {\bf  arg0})
}%end signature
}%end item
\end{itemize}
}
\subsection{Members inherited from class HamiltonianCycleAlgorithmBase }{
\texttt{org.jgrapht.alg.tour.HamiltonianCycleAlgorithmBase} {\small 
\refdefined{org.jgrapht.alg.tour.HamiltonianCycleAlgorithmBase}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{protected void {\bf  checkGraph}(\texttt{org.jgrapht.Graph} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected GraphPath {\bf  closedVertexListToTour}(\texttt{java.util.List} {\bf  arg0},
\texttt{org.jgrapht.Graph} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected GraphPath {\bf  edgeSetToTour}(\texttt{java.util.Set} {\bf  arg0},
\texttt{org.jgrapht.Graph} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected GraphPath {\bf  getSingletonTour}(\texttt{org.jgrapht.Graph} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected void {\bf  requireNotEmpty}(\texttt{org.jgrapht.Graph} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected GraphPath {\bf  vertexListToTour}(\texttt{java.util.List} {\bf  arg0},
\texttt{org.jgrapht.Graph} {\bf  arg1})
}%end signature
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey}Class FlightCacheKey}{
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey}{}\vskip .1in 
A class which holds data about the input values of the flight planning algorithm from a position to a sensor, potentially with a next sensor. This is for use in the cache, so stores hashed value directly in order to save memory and time calculating extra hashes.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class FlightCacheKey
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.currentHash}{{\bf currentHash}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.hashcode}{{\bf hashcode}} A hash of the parameters\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.nextHash}{{\bf nextHash}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.startHash}{{\bf startHash}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf FlightCacheKey(Coords, Coords, Coords)}} Constructor\\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.equals(java.lang.Object)}{{\bf equals(Object)}} Needed to work with a HashMap, automatically generated by IntelliJ.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.hashCode()}{{\bf hashCode()}} Since this class stores the hashcode directly, we do not do any computation and just return it.\\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{hashcode}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.hashcode}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.hashcode}{\texttt{private final int\ {\bf  hashcode}}
}
\begin{itemize}
\item{\vskip -.9ex 
A hash of the parameters}
\end{itemize}
}
\item{
\index{startHash}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.startHash}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.startHash}{\texttt{private final int\ {\bf  startHash}}
}
}
\item{
\index{currentHash}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.currentHash}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.currentHash}{\texttt{private final int\ {\bf  currentHash}}
}
}
\item{
\index{nextHash}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.nextHash}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.nextHash}{\texttt{private final int\ {\bf  nextHash}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{FlightCacheKey(Coords, Coords, Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  FlightCacheKey}\\}
\begin{lstlisting}[frame=none]
public FlightCacheKey(uk.ac.ed.inf.aqmaps.geometry.Coords startPosition,uk.ac.ed.inf.aqmaps.geometry.Coords currentTarget,uk.ac.ed.inf.aqmaps.geometry.Coords nextTarget)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Constructor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{startPosition} -- the start position of the drone.}
   \item{
\texttt{currentTarget} -- the current target}
   \item{
\texttt{nextTarget} -- the next target if there is one, or null otherwise}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{equals(Object)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.equals(java.lang.Object)}{{\bf  equals}\\}
\begin{lstlisting}[frame=none]
public boolean equals(java.lang.Object o)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Needed to work with a HashMap, automatically generated by IntelliJ.
}
\end{itemize}
}%end item
\item{ 
\index{hashCode()}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheKey.hashCode()}{{\bf  hashCode}\\}
\begin{lstlisting}[frame=none]
public int hashCode()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Since this class stores the hashcode directly, we do not do any computation and just return it.
}
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue}Class FlightCacheValue}{
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue}{}\vskip .1in 
A class which holds data about the output values of the flight planning algorithm from a position to a sensor, potentially with a next sensor. This does not hold the actual tour, and is only used for the size of the tour, as it would use a lot of memory.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class FlightCacheValue
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue.endPosition}{{\bf endPosition}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue.length}{{\bf length}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue(int, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf FlightCacheValue(int, Coords)}} Constructor\\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue.getEndPosition()}{{\bf getEndPosition()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue.getLength()}{{\bf getLength()}} \\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{length}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue.length}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue.length}{\texttt{private final int\ {\bf  length}}
}
}
\item{
\index{endPosition}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue.endPosition}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue.endPosition}{\texttt{private final uk.ac.ed.inf.aqmaps.geometry.Coords\ {\bf  endPosition}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{FlightCacheValue(int, Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue(int, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  FlightCacheValue}\\}
\begin{lstlisting}[frame=none]
public FlightCacheValue(int length,uk.ac.ed.inf.aqmaps.geometry.Coords endPosition)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Constructor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{length} -- the number of moves in this flight path section}
   \item{
\texttt{endPosition} -- the ending position of the drone in this flight path section}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getEndPosition()}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue.getEndPosition()}{{\bf  getEndPosition}\\}
\begin{lstlisting}[frame=none]
public uk.ac.ed.inf.aqmaps.geometry.Coords getEndPosition()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the ending position of the drone in this flight path section 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLength()}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightCacheValue.getLength()}{{\bf  getLength}\\}
\begin{lstlisting}[frame=none]
public int getLength()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the number of moves in this flight path section 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan}Class FlightPlan}{
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan}{}\vskip .1in 
A wrapper class for a flight plan as a list of moves, and the random seed that was used to generate it. This is needed so that results can be sorted by seed before finding the minimum, allowing for consistent operation even when concurrency is used.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class FlightPlan
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.moves}{{\bf moves}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.seed}{{\bf seed}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan(int, java.util.List)}{{\bf FlightPlan(int, List)}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.getMoves()}{{\bf getMoves()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.getMovesWithLimit()}{{\bf getMovesWithLimit()}} Get the list of moves in the flight plan, limited to a maximum of 150 moves.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.getSeed()}{{\bf getSeed()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.toString()}{{\bf toString()}} \\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{seed}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.seed}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.seed}{\texttt{private final int\ {\bf  seed}}
}
}
\item{
\index{moves}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.moves}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.moves}{\texttt{private final java.util.List\ {\bf  moves}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{FlightPlan(int, List)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan(int, java.util.List)}{{\bf  FlightPlan}\\}
\begin{lstlisting}[frame=none]
public FlightPlan(int seed,java.util.List moves)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{seed} -- the random seed that his flight plan used}
   \item{
\texttt{moves} -- the list of move which makes up the flight plan}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getMoves()}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.getMoves()}{{\bf  getMoves}\\}
\begin{lstlisting}[frame=none]
public java.util.List getMoves()\end{lstlisting} %end signature
}%end item
\item{ 
\index{getMovesWithLimit()}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.getMovesWithLimit()}{{\bf  getMovesWithLimit}\\}
\begin{lstlisting}[frame=none]
public java.util.List getMovesWithLimit()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Get the list of moves in the flight plan, limited to a maximum of 150 moves. In testing with the current possible input values, this never came close actually limiting the number of moves.
}
\item{{\bf  Returns} -- 
a list of moves of length = 150 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSeed()}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.getSeed()}{{\bf  getSeed}\\}
\begin{lstlisting}[frame=none]
public int getSeed()\end{lstlisting} %end signature
}%end item
\item{ 
\index{toString()}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlan.toString()}{{\bf  toString}\\}
\begin{lstlisting}[frame=none]
public java.lang.String toString()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner}Class FlightPlanner}{
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner}{}\vskip .1in 
Handles the creation of a flight plan for the drone. Uses JGraphT's TwoOptHeuristicTSP algorithm as part of process, which was the best performing of JGraphT's Hamiltonian Cycle algorithms, however this could be changed easily.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class FlightPlanner
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.atomicSeedCounter}{{\bf atomicSeedCounter}} Holds the next random seed to be used when creating the next plan.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.cache}{{\bf cache}} Caches the number of moves and end position of navigating from a point to a target, with a particular following target.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.CORNER_CUT_RADIUS_FRACTION}{{\bf CORNER\_CUT\_RADIUS\_FRACTION}} See \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.cutCorner(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{cutCorner(Coords, Coords, Coords)}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.cutCorner(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}} This value performed the best in testing.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.ITERATIONS}{{\bf ITERATIONS}} When the time limit is off, this is the number of times to run the algorithm before picking the shortest.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.MAX_ITERATIONS}{{\bf MAX\_ITERATIONS}} When the time limit is on, this is the maximum possible number of iterations.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.obstacles}{{\bf obstacles}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.sensorCoordsW3WMap}{{\bf sensorCoordsW3WMap}} A map from coordinates to the W3W of a sensor at that location.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.startTime}{{\bf startTime}} The System.nanoTime() at which we started running flight planning algorithms.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.timeLimitNanos}{{\bf timeLimitNanos}} The approximate maximum run time for flight planning in nanoseconds (to work with System.nanoTime()).\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.timeLimitOn}{{\bf timeLimitOn}} The time limit can be turned off to run for a specified \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.ITERATIONS}{ITERATIONS}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.ITERATIONS}} number of iterations to produce consistent output.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.timerStarted}{{\bf timerStarted}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.TWO_OPT_PASSES}{{\bf TWO\_OPT\_PASSES}} The number of initial tours to try when running 2-opt.\\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner(uk.ac.ed.inf.aqmaps.noflyzone.Obstacles, java.util.List, int, double)}{{\bf FlightPlanner(Obstacles, List, int, double)}} Construct a flight planner with the given time limit in seconds.\\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.computeFlightLength(java.util.List)}{{\bf computeFlightLength(List)}} Computes the length of a flight plan which follows the given sensor coordinate tour.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.constructFlightAlongTour(java.util.List)}{{\bf constructFlightAlongTour(List)}} Create a flight plan for the drone along the given sensor tour.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.createBestFlightPlan(uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf createBestFlightPlan(Coords)}} Create a flight plan for the drone which visits all sensors and returns to the start.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.createPlan(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.flightplanning.SensorGraph)}{{\bf createPlan(Coords, SensorGraph)}} Creates a flight plan for the drone which visits all sensors and returns to the start.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.cutCorner(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf cutCorner(Coords, Coords, Coords)}} Attempts to cut the corner by moving from the target a distance of WaypointNavigation\#SENSOR\_RANGE * \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.CORNER_CUT_RADIUS_FRACTION}{CORNER\_CUT\_RADIUS\_FRACTION}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.CORNER_CUT_RADIUS_FRACTION}} in a direction between the current position and the next target.\\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{TWO\_OPT\_PASSES}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.TWO_OPT_PASSES}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.TWO_OPT_PASSES}{\texttt{private static final int\ {\bf  TWO\_OPT\_PASSES}}
}
\begin{itemize}
\item{\vskip -.9ex 
The number of initial tours to try when running 2-opt. Increasing this does not necessarily reduce average path length, and may increase it, since it will introduce less variability in what goes into the flight-plan mode 2-opt. We do not want the tours given to the improver to all be similarly optimal, since the two tour weight measures are different. There is a trade off to be had between this constant and the number of times the algorithm runs}
\end{itemize}
}
\item{
\index{ITERATIONS}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.ITERATIONS}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.ITERATIONS}{\texttt{private static final int\ {\bf  ITERATIONS}}
}
\begin{itemize}
\item{\vskip -.9ex 
When the time limit is off, this is the number of times to run the algorithm before picking the shortest. Can be changed to trade off for speed and efficacy. Increasing it has diminishing returns.}
\end{itemize}
}
\item{
\index{MAX\_ITERATIONS}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.MAX_ITERATIONS}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.MAX_ITERATIONS}{\texttt{private static final int\ {\bf  MAX\_ITERATIONS}}
}
\begin{itemize}
\item{\vskip -.9ex 
When the time limit is on, this is the maximum possible number of iterations. If this many are run before the time is up, it stops and does not wait for the timer. The current value is high enough for this to never happen.}
\end{itemize}
}
\item{
\index{CORNER\_CUT\_RADIUS\_FRACTION}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.CORNER_CUT_RADIUS_FRACTION}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.CORNER_CUT_RADIUS_FRACTION}{\texttt{private static final double\ {\bf  CORNER\_CUT\_RADIUS\_FRACTION}}
}
\begin{itemize}
\item{\vskip -.9ex 
See \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.cutCorner(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{cutCorner(Coords, Coords, Coords)}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.cutCorner(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}} This value performed the best in testing.}
\end{itemize}
}
\item{
\index{obstacles}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.obstacles}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.obstacles}{\texttt{private final uk.ac.ed.inf.aqmaps.noflyzone.Obstacles\ {\bf  obstacles}}
}
}
\item{
\index{sensorCoordsW3WMap}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.sensorCoordsW3WMap}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.sensorCoordsW3WMap}{\texttt{private final java.util.Map\ {\bf  sensorCoordsW3WMap}}
}
\begin{itemize}
\item{\vskip -.9ex 
A map from coordinates to the W3W of a sensor at that location.}
\end{itemize}
}
\item{
\index{cache}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.cache}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.cache}{\texttt{private final java.util.Map\ {\bf  cache}}
}
\begin{itemize}
\item{\vskip -.9ex 
Caches the number of moves and end position of navigating from a point to a target, with a particular following target. Used in \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.computeFlightLength(java.util.List)}{computeFlightLength(List)}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.computeFlightLength(java.util.List)}}. This does not cache the actual moves that would be needed to use the cache in \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.constructFlightAlongTour(java.util.List)}{constructFlightAlongTour(List)}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.constructFlightAlongTour(java.util.List)}} since the memory use would be too high and almost all of the moves stored would not be used since we only need to construct the tour once. Using a cache in testing resulted in a speedup of 60-70\%. Since \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.computeFlightLength(java.util.List)}{computeFlightLength(List)}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.computeFlightLength(java.util.List)}} will be run in parallel, we use a ConcurrentHashMap to prevent blocking, which was about 60\%\ faster than a Hashtable in testing (on 6 cores/12 threads).}
\end{itemize}
}
\item{
\index{atomicSeedCounter}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.atomicSeedCounter}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.atomicSeedCounter}{\texttt{private final java.util.concurrent.atomic.AtomicInteger\ {\bf  atomicSeedCounter}}
}
\begin{itemize}
\item{\vskip -.9ex 
Holds the next random seed to be used when creating the next plan. This is used so when the time limit is being used to cut off execution, it will have run using the first seeds in the planned sequence (seed, seed+1, seed+2, ...). The alternative is to create this sequence in advance and then run through it with map(), however when executed in parallel they would not be executed starting from the front, and the seeds that were chosen would end up being essentially random.

Using this allows to say with confidence that if the algorithm produced a flight plan in n iterations, that flight plan used a random seed between the command line input seed and (seed+n), and you would be able to generate the same flight plan again.}
\end{itemize}
}
\item{
\index{timeLimitOn}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.timeLimitOn}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.timeLimitOn}{\texttt{private final boolean\ {\bf  timeLimitOn}}
}
\begin{itemize}
\item{\vskip -.9ex 
The time limit can be turned off to run for a specified \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.ITERATIONS}{ITERATIONS}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.ITERATIONS}} number of iterations to produce consistent output.}
\end{itemize}
}
\item{
\index{timerStarted}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.timerStarted}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.timerStarted}{\texttt{private final java.util.concurrent.atomic.AtomicBoolean\ {\bf  timerStarted}}
}
}
\item{
\index{timeLimitNanos}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.timeLimitNanos}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.timeLimitNanos}{\texttt{private long\ {\bf  timeLimitNanos}}
}
\begin{itemize}
\item{\vskip -.9ex 
The approximate maximum run time for flight planning in nanoseconds (to work with System.nanoTime()). The algorithm will repeat as many times as possible with different random seeds within this time frame, up to a maximum of MAX\_ITERATIONS and then the best flight path will be chosen. High values of this have highly diminishing returns.}
\end{itemize}
}
\item{
\index{startTime}
\label{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.startTime}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.startTime}{\texttt{private double\ {\bf  startTime}}
}
\begin{itemize}
\item{\vskip -.9ex 
The System.nanoTime() at which we started running flight planning algorithms.}
\end{itemize}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{FlightPlanner(Obstacles, List, int, double)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner(uk.ac.ed.inf.aqmaps.noflyzone.Obstacles, java.util.List, int, double)}{{\bf  FlightPlanner}\\}
\begin{lstlisting}[frame=none]
public FlightPlanner(uk.ac.ed.inf.aqmaps.noflyzone.Obstacles obstacles,java.util.List sensorW3Ws,int randomSeed,double timeLimit)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Construct a flight planner with the given time limit in seconds. If the time limit is not greater than 0, turns it off and uses a maximum number of iterations instead.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{obstacles} -- the Obstacles containing the no-fly zones}
   \item{
\texttt{sensorW3Ws} -- the W3W locations of the sensors}
   \item{
\texttt{randomSeed} -- the initial random seed to use}
   \item{
\texttt{timeLimit} -- the time limit for the algorithm in seconds. If it is equal to 0 then disables the time limit and runs for a fixed number of iterations.}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{computeFlightLength(List)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.computeFlightLength(java.util.List)}{{\bf  computeFlightLength}\\}
\begin{lstlisting}[frame=none]
public int computeFlightLength(java.util.List tour)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Computes the length of a flight plan which follows the given sensor coordinate tour.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{tour} -- a list of Coords specifying the order to visit the sensors}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the number of moves in the flight plan 
}%end item
\end{itemize}
}%end item
\item{ 
\index{constructFlightAlongTour(List)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.constructFlightAlongTour(java.util.List)}{{\bf  constructFlightAlongTour}\\}
\begin{lstlisting}[frame=none]
private java.util.List constructFlightAlongTour(java.util.List tour)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Create a flight plan for the drone along the given sensor tour.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{tour} -- a list of Coords specifying the order to visit the sensors}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a list of Moves representing the flight plan 
}%end item
\end{itemize}
}%end item
\item{ 
\index{createBestFlightPlan(Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.createBestFlightPlan(uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  createBestFlightPlan}\\}
\begin{lstlisting}[frame=none]
public java.util.List createBestFlightPlan(uk.ac.ed.inf.aqmaps.geometry.Coords startPosition)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Create a flight plan for the drone which visits all sensors and returns to the start. Runs the algorithm a large number of times with different random seeds, in parallel, and chooses the shortest.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{startPosition} -- the starting position of the drone}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a list of Moves representing the flight plan 
}%end item
\end{itemize}
}%end item
\item{ 
\index{createPlan(Coords, SensorGraph)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.createPlan(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.flightplanning.SensorGraph)}{{\bf  createPlan}\\}
\begin{lstlisting}[frame=none]
private FlightPlan createPlan(uk.ac.ed.inf.aqmaps.geometry.Coords startPosition,SensorGraph sensorGraph)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Creates a flight plan for the drone which visits all sensors and returns to the start. First uses an two stage 2-opt heuristic (see \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP}{EnhancedTwoOptTSP}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.flightplanning.EnhancedTwoOptTSP}}) to generate a tour, then constructs a flight plan for the drone along the route.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{startPosition} -- the starting position of the drone}
   \item{
\texttt{sensorGraph} -- the graph containing all of the sensors and distances}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a list of Moves representing the flight plan 
}%end item
\end{itemize}
}%end item
\item{ 
\index{cutCorner(Coords, Coords, Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.cutCorner(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  cutCorner}\\}
\begin{lstlisting}[frame=none]
private uk.ac.ed.inf.aqmaps.geometry.Coords cutCorner(uk.ac.ed.inf.aqmaps.geometry.Coords currPos,uk.ac.ed.inf.aqmaps.geometry.Coords target,uk.ac.ed.inf.aqmaps.geometry.Coords nextTarget)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Attempts to cut the corner by moving from the target a distance of WaypointNavigation\#SENSOR\_RANGE * \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.CORNER_CUT_RADIUS_FRACTION}{CORNER\_CUT\_RADIUS\_FRACTION}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.flightplanning.FlightPlanner.CORNER_CUT_RADIUS_FRACTION}} in a direction between the current position and the next target. It tries 3 directions: the bisector between the directions, and the 2 recursive bisectors (3 equally spaced directions). Picks the target which minimises the new path that goes through the new point, and does not collide with an obstacle. If none of the new targets are an improvement, outputs the original target.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{currPos} -- the position of the drone before it will move towards the target}
   \item{
\texttt{target} -- the location of the target}
   \item{
\texttt{nextTarget} -- the location of the target after the current target}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a new target, which has potentially been moved in order to cut the corner 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.flightplanning.SensorGraph}Class SensorGraph}{
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.SensorGraph}{}\vskip .1in 
A graph of the sensors and their distances to each other, taking into account obstacle evasion.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class SensorGraph
 extends org.jgrapht.graph.SimpleWeightedGraph\end{lstlisting}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.SensorGraph(uk.ac.ed.inf.aqmaps.geometry.Coords, java.util.Collection, uk.ac.ed.inf.aqmaps.noflyzone.Obstacles)}{{\bf SensorGraph(Coords, Collection, Obstacles)}} Private Constructor\\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.SensorGraph.createWithStartLocation(uk.ac.ed.inf.aqmaps.geometry.Coords, java.util.Collection, uk.ac.ed.inf.aqmaps.noflyzone.Obstacles)}{{\bf createWithStartLocation(Coords, Collection, Obstacles)}} Creates a complete weighted graph with the points of all of the sensors and the starting position.\\
\end{verse}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{SensorGraph(Coords, Collection, Obstacles)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.SensorGraph(uk.ac.ed.inf.aqmaps.geometry.Coords, java.util.Collection, uk.ac.ed.inf.aqmaps.noflyzone.Obstacles)}{{\bf  SensorGraph}\\}
\begin{lstlisting}[frame=none]
private SensorGraph(uk.ac.ed.inf.aqmaps.geometry.Coords startPosition,java.util.Collection sensorCoords,uk.ac.ed.inf.aqmaps.noflyzone.Obstacles obstacles)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Private Constructor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{startPosition} -- the starting position of the drone}
   \item{
\texttt{sensorCoords} -- a Collection of the Coords of the sensors to be visited}
   \item{
\texttt{obstacles} -- the Obstacles that need to be avoided}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{createWithStartLocation(Coords, Collection, Obstacles)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.SensorGraph.createWithStartLocation(uk.ac.ed.inf.aqmaps.geometry.Coords, java.util.Collection, uk.ac.ed.inf.aqmaps.noflyzone.Obstacles)}{{\bf  createWithStartLocation}\\}
\begin{lstlisting}[frame=none]
public static SensorGraph createWithStartLocation(uk.ac.ed.inf.aqmaps.geometry.Coords startPosition,java.util.Collection sensorCoords,uk.ac.ed.inf.aqmaps.noflyzone.Obstacles obstacles)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Creates a complete weighted graph with the points of all of the sensors and the starting position. The edge weights are the shortest distance between the points, avoiding obstacles if necessary.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{startPosition} -- the starting position of the drone}
   \item{
\texttt{sensorCoords} -- a Collection of the Coords of the sensors to be visited}
   \item{
\texttt{obstacles} -- the Obstacles that need to be avoided}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a SensorGraph 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Members inherited from class SimpleWeightedGraph }{
\texttt{org.jgrapht.graph.SimpleWeightedGraph} {\small 
\refdefined{org.jgrapht.graph.SimpleWeightedGraph}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public static GraphBuilder {\bf  createBuilder}(\texttt{java.lang.Class} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static GraphBuilder {\bf  createBuilder}(\texttt{java.util.function.Supplier} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  serialVersionUID}}%end signature
}%end item
\end{itemize}
}
\subsection{Members inherited from class SimpleGraph }{
\texttt{org.jgrapht.graph.SimpleGraph} {\small 
\refdefined{org.jgrapht.graph.SimpleGraph}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public static GraphBuilder {\bf  createBuilder}(\texttt{java.lang.Class} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static GraphBuilder {\bf  createBuilder}(\texttt{java.util.function.Supplier} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  serialVersionUID}}%end signature
}%end item
\end{itemize}
}
\subsection{Members inherited from class AbstractBaseGraph }{
\texttt{org.jgrapht.graph.AbstractBaseGraph} {\small 
\refdefined{org.jgrapht.graph.AbstractBaseGraph}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public Object {\bf  addEdge}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  addEdge}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1},
\texttt{java.lang.Object} {\bf  arg2})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Object {\bf  addVertex}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  addVertex}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Object {\bf  clone}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  containsEdge}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  containsVertex}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public int {\bf  degreeOf}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  edgeSet}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  edgesOf}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  edgeSupplier}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  getAllEdges}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Object {\bf  getEdge}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Object {\bf  getEdgeSource}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Supplier {\bf  getEdgeSupplier}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Object {\bf  getEdgeTarget}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public double {\bf  getEdgeWeight}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public GraphType {\bf  getType}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Supplier {\bf  getVertexSupplier}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  GRAPH\_SPECIFICS\_MUST\_NOT\_BE\_NULL}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  GRAPH\_SPECIFICS\_STRATEGY\_REQUIRED}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  graphSpecificsStrategy}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  incomingEdgesOf}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public int {\bf  inDegreeOf}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  intrusiveEdgesSpecifics}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  INVALID\_VERTEX\_SUPPLIER\_DOES\_NOT\_RETURN\_UNIQUE\_VERTICES\_ON\_EACH\_CALL}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  LOOPS\_NOT\_ALLOWED}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  MIXED\_GRAPH\_NOT\_SUPPORTED}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public int {\bf  outDegreeOf}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  outgoingEdgesOf}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  removeEdge}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Object {\bf  removeEdge}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  removeVertex}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  serialVersionUID}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public void {\bf  setEdgeSupplier}(\texttt{java.util.function.Supplier} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public void {\bf  setEdgeWeight}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{double} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public void {\bf  setVertexSupplier}(\texttt{java.util.function.Supplier} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  specifics}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  THE\_GRAPH\_CONTAINS\_NO\_EDGE\_SUPPLIER}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  THE\_GRAPH\_CONTAINS\_NO\_VERTEX\_SUPPLIER}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  type}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private transient {\bf  unmodifiableVertexSet}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  vertexSet}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  vertexSupplier}}%end signature
}%end item
\end{itemize}
}
\subsection{Members inherited from class AbstractGraph }{
\texttt{org.jgrapht.graph.AbstractGraph} {\small 
\refdefined{org.jgrapht.graph.AbstractGraph}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{protected boolean {\bf  assertVertexExist}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  containsEdge}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  equals}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public int {\bf  hashCode}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  removeAllEdges}(\texttt{java.util.Collection} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected boolean {\bf  removeAllEdges}(\texttt{java.lang.Object\lbrack \rbrack } {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  removeAllEdges}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  removeAllVertices}(\texttt{java.util.Collection} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public String {\bf  toString}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected String {\bf  toStringFromSets}(\texttt{java.util.Collection} {\bf  arg0},
\texttt{java.util.Collection} {\bf  arg1},
\texttt{boolean} {\bf  arg2})
}%end signature
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation}Class WaypointNavigation}{
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation}{}\vskip .1in 
A class which handles the navigation of the drone along a series of waypoints to a target. This is the core of the drone control algorithm that plans the movement of the drone itself including all rules about move lengths and directions.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class WaypointNavigation
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.countIterations}{{\bf countIterations}} Count the number if times that navigateToLocation is called\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.END_POSITION_RANGE}{{\bf END\_POSITION\_RANGE}} The drone must be within this distance of the end position at the end of the flight\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.MOVE_LENGTH}{{\bf MOVE\_LENGTH}} The distance the drone travels in one move.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.obstacles}{{\bf obstacles}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.OFFSETS}{{\bf OFFSETS}} The offsets from the direct direction to try when looking for a direction to move in.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.SENSOR_RANGE}{{\bf SENSOR\_RANGE}} The drone must be within this distance of a sensor to be able to read it.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.targetLocation}{{\bf targetLocation}} The target location, such as a sensor or end position\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.targetSensorW3W}{{\bf targetSensorW3W}} If the target is a sensor holds its W3W location, otherwise null\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.visitedSet}{{\bf visitedSet}} Keeps track of all of the points we have visited so far so we can avoid looping back on ourselves.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.waypoints}{{\bf waypoints}} A list of Coords waypoints for the drone to follow on its way to the target.\\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation(uk.ac.ed.inf.aqmaps.noflyzone.Obstacles)}{{\bf WaypointNavigation(Obstacles)}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.inRangeOfTarget(uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf inRangeOfTarget(Coords)}} Determines whether or not the position is in range of the target.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.navigateAlongWaypoints(uk.ac.ed.inf.aqmaps.geometry.Coords, int, int)}{{\bf navigateAlongWaypoints(Coords, int, int)}} Recursively finds moves which navigate from waypoint to waypoint, until the target location is reached.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.navigateToLocation(uk.ac.ed.inf.aqmaps.geometry.Coords, java.util.List, uk.ac.ed.inf.aqmaps.W3W)}{{\bf navigateToLocation(Coords, List, W3W)}} Find a sequence of moves that navigates the drone from the current location along the waypoints to the target.\\
\hyperlink{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.predictMaxMoveLength(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf predictMaxMoveLength(Coords, Coords)}} Predict the maximum number of moves to reach the specified waypoint.\\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{MOVE\_LENGTH}
\label{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.MOVE_LENGTH}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.MOVE_LENGTH}{\texttt{public static final double\ {\bf  MOVE\_LENGTH}}
}
\begin{itemize}
\item{\vskip -.9ex 
The distance the drone travels in one move.}
\end{itemize}
}
\item{
\index{SENSOR\_RANGE}
\label{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.SENSOR_RANGE}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.SENSOR_RANGE}{\texttt{public static final double\ {\bf  SENSOR\_RANGE}}
}
\begin{itemize}
\item{\vskip -.9ex 
The drone must be within this distance of a sensor to be able to read it.}
\end{itemize}
}
\item{
\index{END\_POSITION\_RANGE}
\label{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.END_POSITION_RANGE}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.END_POSITION_RANGE}{\texttt{public static final double\ {\bf  END\_POSITION\_RANGE}}
}
\begin{itemize}
\item{\vskip -.9ex 
The drone must be within this distance of the end position at the end of the flight}
\end{itemize}
}
\item{
\index{OFFSETS}
\label{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.OFFSETS}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.OFFSETS}{\texttt{private final int\lbrack \rbrack \ {\bf  OFFSETS}}
}
\begin{itemize}
\item{\vskip -.9ex 
The offsets from the direct direction to try when looking for a direction to move in. Starts at 0 and works outwards. This is easier and faster to hardcode than to generate everytime we run navigation.}
\end{itemize}
}
\item{
\index{obstacles}
\label{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.obstacles}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.obstacles}{\texttt{private final uk.ac.ed.inf.aqmaps.noflyzone.Obstacles\ {\bf  obstacles}}
}
}
\item{
\index{visitedSet}
\label{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.visitedSet}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.visitedSet}{\texttt{private final java.util.Set\ {\bf  visitedSet}}
}
\begin{itemize}
\item{\vskip -.9ex 
Keeps track of all of the points we have visited so far so we can avoid looping back on ourselves.}
\end{itemize}
}
\item{
\index{waypoints}
\label{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.waypoints}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.waypoints}{\texttt{private java.util.List\ {\bf  waypoints}}
}
\begin{itemize}
\item{\vskip -.9ex 
A list of Coords waypoints for the drone to follow on its way to the target.}
\end{itemize}
}
\item{
\index{targetLocation}
\label{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.targetLocation}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.targetLocation}{\texttt{private uk.ac.ed.inf.aqmaps.geometry.Coords\ {\bf  targetLocation}}
}
\begin{itemize}
\item{\vskip -.9ex 
The target location, such as a sensor or end position}
\end{itemize}
}
\item{
\index{targetSensorW3W}
\label{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.targetSensorW3W}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.targetSensorW3W}{\texttt{private uk.ac.ed.inf.aqmaps.W3W\ {\bf  targetSensorW3W}}
}
\begin{itemize}
\item{\vskip -.9ex 
If the target is a sensor holds its W3W location, otherwise null}
\end{itemize}
}
\item{
\index{countIterations}
\label{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.countIterations}\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.countIterations}{\texttt{private int\ {\bf  countIterations}}
}
\begin{itemize}
\item{\vskip -.9ex 
Count the number if times that navigateToLocation is called}
\end{itemize}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{WaypointNavigation(Obstacles)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation(uk.ac.ed.inf.aqmaps.noflyzone.Obstacles)}{{\bf  WaypointNavigation}\\}
\begin{lstlisting}[frame=none]
public WaypointNavigation(uk.ac.ed.inf.aqmaps.noflyzone.Obstacles obstacles)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{obstacles} -- the obstacles for collision checking}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{inRangeOfTarget(Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.inRangeOfTarget(uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  inRangeOfTarget}\\}
\begin{lstlisting}[frame=none]
private boolean inRangeOfTarget(uk.ac.ed.inf.aqmaps.geometry.Coords position)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Determines whether or not the position is in range of the target. The range that determines this depends on whether the target is a sensor or the start/end position of the drone.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{position} -- the position}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
true if it is in range of the target sensor or end position, false otherwise 
}%end item
\end{itemize}
}%end item
\item{ 
\index{navigateAlongWaypoints(Coords, int, int)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.navigateAlongWaypoints(uk.ac.ed.inf.aqmaps.geometry.Coords, int, int)}{{\bf  navigateAlongWaypoints}\\}
\begin{lstlisting}[frame=none]
private java.util.List navigateAlongWaypoints(uk.ac.ed.inf.aqmaps.geometry.Coords currentPosition,int currWaypoint,int movesTilTimeout)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Recursively finds moves which navigate from waypoint to waypoint, until the target location is reached.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{currentPosition} -- the current position of the drone}
   \item{
\texttt{currWaypoint} -- the current waypoint number}
   \item{
\texttt{movesTilTimeout} -- the maximum number of moves to the next waypoint until the current branch of the search is ended}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a list of moves which take the drone from the current location to the target 
}%end item
\end{itemize}
}%end item
\item{ 
\index{navigateToLocation(Coords, List, W3W)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.navigateToLocation(uk.ac.ed.inf.aqmaps.geometry.Coords, java.util.List, uk.ac.ed.inf.aqmaps.W3W)}{{\bf  navigateToLocation}\\}
\begin{lstlisting}[frame=none]
public java.util.List navigateToLocation(uk.ac.ed.inf.aqmaps.geometry.Coords startingPosition,java.util.List waypoints,uk.ac.ed.inf.aqmaps.W3W targetSensorW3W)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Find a sequence of moves that navigates the drone from the current location along the waypoints to the target.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{startingPosition} -- the starting position of the drone}
   \item{
\texttt{waypoints} -- a list of Coords waypoints for the drone to follow on its way to the target.}
   \item{
\texttt{targetSensorW3W} -- the W3W of the target sensor, or null if the target is not a sensor.}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a list of Moves that navigate the drone from the starting position to in range of the target 
}%end item
\end{itemize}
}%end item
\item{ 
\index{predictMaxMoveLength(Coords, Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.flightplanning.WaypointNavigation.predictMaxMoveLength(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  predictMaxMoveLength}\\}
\begin{lstlisting}[frame=none]
private int predictMaxMoveLength(uk.ac.ed.inf.aqmaps.geometry.Coords startPos,uk.ac.ed.inf.aqmaps.geometry.Coords target)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Predict the maximum number of moves to reach the specified waypoint. The formula is ceiling(distance / MOVE\_LENGTH) + 2.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{startPos} -- the starting position of the move}
   \item{
\texttt{target} -- the target waypoint of the move}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the estimated maximum number of moves that it will take to reach the target 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
}
\chapter{Package uk.ac.ed.inf.aqmaps.geometry}{
\label{uk.ac.ed.inf.aqmaps.geometry}\hypertarget{uk.ac.ed.inf.aqmaps.geometry}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\hbox{{\bf  Classes}}
\entityintro{Coords}{uk.ac.ed.inf.aqmaps.geometry.Coords}{Holds a longitude and latitude pair, using a Point2D.}
\entityintro{Polygon}{uk.ac.ed.inf.aqmaps.geometry.Polygon}{Holds a polygon as a list of the Coords that make up the vertices, in order}
\vskip .1in
\vskip .1in
\section{\label{uk.ac.ed.inf.aqmaps.geometry.Coords}Class Coords}{
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Coords}{}\vskip .1in 
Holds a longitude and latitude pair, using a Point2D. This class uses euclidean geometry and its calculations do {\bf not} match with real life.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class Coords
 extends java.awt.geom.Point2D.Double\end{lstlisting}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Coords(double, double)}{{\bf Coords(double, double)}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Coords.bisectorDirection(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf bisectorDirection(Coords, Coords)}} Let this point be P.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Coords.buildFromGeojsonPoint(com.mapbox.geojson.Point)}{{\bf buildFromGeojsonPoint(Point)}} Convert a mapbox point into a Coords\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Coords.directionTo(uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf directionTo(Coords)}} Let this point be P.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Coords.getPointOnBisector(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords, double)}{{\bf getPointOnBisector(Coords, Coords, double)}} Let this point be P.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Coords.getPositionAfterMoveDegrees(double, double)}{{\bf getPositionAfterMoveDegrees(double, double)}} Creates a new Coords which is the result of moving from the current location at the specified angle for the specified length.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Coords.getPositionAfterMoveRadians(double, double)}{{\bf getPositionAfterMoveRadians(double, double)}} Creates a new Coords which is the result of moving from the current location at the specified angle for the specified length.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Coords.roundedDirection10Degrees(uk.ac.ed.inf.aqmaps.geometry.Coords, int)}{{\bf roundedDirection10Degrees(Coords, int)}} Let this point be P.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Coords.toString()}{{\bf toString()}} Used for printing Coords for debugging\\
\end{verse}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Coords(double, double)}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Coords(double, double)}{{\bf  Coords}\\}
\begin{lstlisting}[frame=none]
public Coords(double lng,double lat)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{lng} -- longitude}
   \item{
\texttt{lat} -- latitude}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{bisectorDirection(Coords, Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Coords.bisectorDirection(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  bisectorDirection}\\}
\begin{lstlisting}[frame=none]
public double bisectorDirection(Coords A,Coords B)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Let this point be P. Calculate the direction of the acute bisector between the lines PA and PB.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{A} -- point A}
   \item{
\texttt{B} -- point B}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the direction of the bisector in radians 
}%end item
\end{itemize}
}%end item
\item{ 
\index{buildFromGeojsonPoint(Point)}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Coords.buildFromGeojsonPoint(com.mapbox.geojson.Point)}{{\bf  buildFromGeojsonPoint}\\}
\begin{lstlisting}[frame=none]
public static Coords buildFromGeojsonPoint(com.mapbox.geojson.Point p)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Convert a mapbox point into a Coords
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{p} -- the mapbox Point}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
an equivalent Coords 
}%end item
\end{itemize}
}%end item
\item{ 
\index{directionTo(Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Coords.directionTo(uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  directionTo}\\}
\begin{lstlisting}[frame=none]
public double directionTo(Coords A)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Let this point be P. Calculates the direction or angle of the line PA with respect to the horizontal, where east is 0, north is pi/2, south is -pi/2, west is pi
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{A} -- point A}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the direction in radians 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getPointOnBisector(Coords, Coords, double)}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Coords.getPointOnBisector(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords, double)}{{\bf  getPointOnBisector}\\}
\begin{lstlisting}[frame=none]
public Coords getPointOnBisector(Coords A,Coords B,double distance)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Let this point be P. Creates a point a specified distance away in the direction of the acute bisector between the lines PA and PB.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{A} -- point A}
   \item{
\texttt{B} -- point B}
   \item{
\texttt{distance} -- the distance the new point should be away from this point}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the new point 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getPositionAfterMoveDegrees(double, double)}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Coords.getPositionAfterMoveDegrees(double, double)}{{\bf  getPositionAfterMoveDegrees}\\}
\begin{lstlisting}[frame=none]
public Coords getPositionAfterMoveDegrees(double degrees,double length)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Creates a new Coords which is the result of moving from the current location at the specified angle for the specified length. Angle in degrees version.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{degrees} -- the direction of the move as an angle in degrees}
   \item{
\texttt{length} -- the length of the move}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a Coords containing the calculated point 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getPositionAfterMoveRadians(double, double)}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Coords.getPositionAfterMoveRadians(double, double)}{{\bf  getPositionAfterMoveRadians}\\}
\begin{lstlisting}[frame=none]
public Coords getPositionAfterMoveRadians(double radians,double length)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Creates a new Coords which is the result of moving from the current location at the specified angle for the specified length. Angle in radians version.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{radians} -- the direction of the move as an angle in radians}
   \item{
\texttt{length} -- the length of the move}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a Coords containing the calculated point 
}%end item
\end{itemize}
}%end item
\item{ 
\index{roundedDirection10Degrees(Coords, int)}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Coords.roundedDirection10Degrees(uk.ac.ed.inf.aqmaps.geometry.Coords, int)}{{\bf  roundedDirection10Degrees}\\}
\begin{lstlisting}[frame=none]
public int roundedDirection10Degrees(Coords A,int offset)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Let this point be P. Calculates the direction of the line PA, rounded to the nearest 10 degrees, offset by an amount, and expressed in the range \lbrack 0,350\rbrack .
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{A} -- point A}
   \item{
\texttt{offset} -- the offset}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the direction in degrees 
}%end item
\end{itemize}
}%end item
\item{ 
\index{toString()}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Coords.toString()}{{\bf  toString}\\}
\begin{lstlisting}[frame=none]
public java.lang.String toString()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Used for printing Coords for debugging
}
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Members inherited from class Point2D.Double }{
\texttt{java.awt.geom.Point2D.Double} {\small 
\refdefined{java.awt.geom.Point2D.Double}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public double {\bf  getX}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public double {\bf  getY}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  serialVersionUID}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public void {\bf  setLocation}(\texttt{double} {\bf  arg0},
\texttt{double} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public String {\bf  toString}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public {\bf  x}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public {\bf  y}}%end signature
}%end item
\end{itemize}
}
\subsection{Members inherited from class Point2D }{
\texttt{java.awt.geom.Point2D} {\small 
\refdefined{java.awt.geom.Point2D}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public Object {\bf  clone}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public double {\bf  distance}(\texttt{double} {\bf  arg0},
\texttt{double} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static double {\bf  distance}(\texttt{double} {\bf  arg0},
\texttt{double} {\bf  arg1},
\texttt{double} {\bf  arg2},
\texttt{double} {\bf  arg3})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public double {\bf  distance}(\texttt{Point2D} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public double {\bf  distanceSq}(\texttt{double} {\bf  arg0},
\texttt{double} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static double {\bf  distanceSq}(\texttt{double} {\bf  arg0},
\texttt{double} {\bf  arg1},
\texttt{double} {\bf  arg2},
\texttt{double} {\bf  arg3})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public double {\bf  distanceSq}(\texttt{Point2D} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  equals}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public abstract double {\bf  getX}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public abstract double {\bf  getY}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public int {\bf  hashCode}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public abstract void {\bf  setLocation}(\texttt{double} {\bf  arg0},
\texttt{double} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public void {\bf  setLocation}(\texttt{Point2D} {\bf  arg0})
}%end signature
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.geometry.Polygon}Class Polygon}{
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon}{}\vskip .1in 
Holds a polygon as a list of the Coords that make up the vertices, in order\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class Polygon
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.boundingBox}{{\bf boundingBox}} A rectangular bounding box which contains the polygon\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.OUTLINE_MARGIN}{{\bf OUTLINE\_MARGIN}} The margin to use when generating a polygon which outlines another, see \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.generateOutlinePoints()}{generateOutlinePoints()}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.geometry.Polygon.generateOutlinePoints()}}\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.path}{{\bf path}} Holds a path around the polygon and is used for checking inside-ness and generating bounding boxes.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.points}{{\bf points}} A list of the vertices of the polygon\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.segments}{{\bf segments}} All of the line segments that make up the edges\\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon(java.util.List)}{{\bf Polygon(List)}} Initialize a Polygon from a list of Coords points\\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.buildFromFeature(com.mapbox.geojson.Feature)}{{\bf buildFromFeature(Feature)}} Create a Polygon from a GeoJSON Polygon\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.contains(uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf contains(Coords)}} Checks whether a given point is containing within this polygon.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.createBoundingBox()}{{\bf createBoundingBox()}} Creates a bounding box that contains the rectangular bounds of the polygon.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.createSegments()}{{\bf createSegments()}} Creates a list of the segments between adjacent points in the polygon.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.generateOutlinePoints()}{{\bf generateOutlinePoints()}} Generates the points of a new polygon which contains the original by a very small margin.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.generatePath2D()}{{\bf generatePath2D()}} Creates a Path2D of the points in this polygon, so we can use its getBounds2D() and contains() methods.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.getPoints()}{{\bf getPoints()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.getSegments()}{{\bf getSegments()}} This method is currently only used in a test, but it is kept to test whether the segments have been created properly.\\
\hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.lineCollision(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf lineCollision(Coords, Coords)}} Determines whether the line segment between the start and end points collides with the polygon.\\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{OUTLINE\_MARGIN}
\label{uk.ac.ed.inf.aqmaps.geometry.Polygon.OUTLINE_MARGIN}\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.OUTLINE_MARGIN}{\texttt{public static final double\ {\bf  OUTLINE\_MARGIN}}
}
\begin{itemize}
\item{\vskip -.9ex 
The margin to use when generating a polygon which outlines another, see \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.generateOutlinePoints()}{generateOutlinePoints()}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.geometry.Polygon.generateOutlinePoints()}}}
\end{itemize}
}
\item{
\index{points}
\label{uk.ac.ed.inf.aqmaps.geometry.Polygon.points}\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.points}{\texttt{private final java.util.List\ {\bf  points}}
}
\begin{itemize}
\item{\vskip -.9ex 
A list of the vertices of the polygon}
\end{itemize}
}
\item{
\index{path}
\label{uk.ac.ed.inf.aqmaps.geometry.Polygon.path}\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.path}{\texttt{private final java.awt.geom.Path2D\ {\bf  path}}
}
\begin{itemize}
\item{\vskip -.9ex 
Holds a path around the polygon and is used for checking inside-ness and generating bounding boxes.}
\end{itemize}
}
\item{
\index{segments}
\label{uk.ac.ed.inf.aqmaps.geometry.Polygon.segments}\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.segments}{\texttt{private final java.util.List\ {\bf  segments}}
}
\begin{itemize}
\item{\vskip -.9ex 
All of the line segments that make up the edges}
\end{itemize}
}
\item{
\index{boundingBox}
\label{uk.ac.ed.inf.aqmaps.geometry.Polygon.boundingBox}\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.boundingBox}{\texttt{private final java.awt.geom.Rectangle2D\ {\bf  boundingBox}}
}
\begin{itemize}
\item{\vskip -.9ex 
A rectangular bounding box which contains the polygon}
\end{itemize}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Polygon(List)}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon(java.util.List)}{{\bf  Polygon}\\}
\begin{lstlisting}[frame=none]
private Polygon(java.util.List points)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Initialize a Polygon from a list of Coords points
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{points} -- a list of Coords}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{buildFromFeature(Feature)}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.buildFromFeature(com.mapbox.geojson.Feature)}{{\bf  buildFromFeature}\\}
\begin{lstlisting}[frame=none]
public static Polygon buildFromFeature(com.mapbox.geojson.Feature feature)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Create a Polygon from a GeoJSON Polygon
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{feature} -- a GeoJSON Feature containing a Polygon}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the converted Polygon 
}%end item
\end{itemize}
}%end item
\item{ 
\index{contains(Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.contains(uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  contains}\\}
\begin{lstlisting}[frame=none]
public boolean contains(Coords p)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Checks whether a given point is containing within this polygon.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{p} -- the point}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
true if the polygon contains the point, false otherwise 
}%end item
\end{itemize}
}%end item
\item{ 
\index{createBoundingBox()}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.createBoundingBox()}{{\bf  createBoundingBox}\\}
\begin{lstlisting}[frame=none]
private java.awt.geom.Rectangle2D createBoundingBox()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Creates a bounding box that contains the rectangular bounds of the polygon.
}
\item{{\bf  Returns} -- 
the bounding box as a Rectangle2D 
}%end item
\end{itemize}
}%end item
\item{ 
\index{createSegments()}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.createSegments()}{{\bf  createSegments}\\}
\begin{lstlisting}[frame=none]
private java.util.List createSegments()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Creates a list of the segments between adjacent points in the polygon.
}
\item{{\bf  Returns} -- 
a list of Segments as Line2D 
}%end item
\end{itemize}
}%end item
\item{ 
\index{generateOutlinePoints()}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.generateOutlinePoints()}{{\bf  generateOutlinePoints}\\}
\begin{lstlisting}[frame=none]
public java.util.List generateOutlinePoints()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Generates the points of a new polygon which contains the original by a very small margin. It generates points a distance of 1.0e-14 from each point in the original Polygon in the direction of the bisecting angle between the two adjacent sides, or the opposite direction if that point is inside the polygon. The resulting polygon will be larger than the original by a margin of 1.0e-14 on all sides.
}
\item{{\bf  Returns} -- 
the outlining Polygon 
}%end item
\end{itemize}
}%end item
\item{ 
\index{generatePath2D()}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.generatePath2D()}{{\bf  generatePath2D}\\}
\begin{lstlisting}[frame=none]
private java.awt.geom.Path2D generatePath2D()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Creates a Path2D of the points in this polygon, so we can use its getBounds2D() and contains() methods.
}
\item{{\bf  Returns} -- 
a Path2D containing the vertices of the polygon 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getPoints()}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.getPoints()}{{\bf  getPoints}\\}
\begin{lstlisting}[frame=none]
public java.util.List getPoints()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the points which make up the vertices of this polygon 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSegments()}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.getSegments()}{{\bf  getSegments}\\}
\begin{lstlisting}[frame=none]
public java.util.List getSegments()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

This method is currently only used in a test, but it is kept to test whether the segments have been created properly.
}
\item{{\bf  Returns} -- 
the segments which make up the edges of the polygon 
}%end item
\end{itemize}
}%end item
\item{ 
\index{lineCollision(Coords, Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.geometry.Polygon.lineCollision(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  lineCollision}\\}
\begin{lstlisting}[frame=none]
public boolean lineCollision(Coords start,Coords end)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Determines whether the line segment between the start and end points collides with the polygon.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{start} -- the coordinates of the start point}
   \item{
\texttt{end} -- the coordinates of the end point}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
true if the segment collides with an obstacle, false otherwise 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
}
\chapter{Package uk.ac.ed.inf.aqmaps.io}{
\label{uk.ac.ed.inf.aqmaps.io}\hypertarget{uk.ac.ed.inf.aqmaps.io}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\hbox{{\bf  Interfaces}}
\entityintro{InputController}{uk.ac.ed.inf.aqmaps.io.InputController}{Handles interaction with input from all remote information sources and devices.}
\entityintro{OutputController}{uk.ac.ed.inf.aqmaps.io.OutputController}{Handles interaction with all output locations.}
\entityintro{Server}{uk.ac.ed.inf.aqmaps.io.Server}{Handles requesting data from a server.}
\vskip .13in
\hbox{{\bf  Classes}}
\entityintro{FileOutputController}{uk.ac.ed.inf.aqmaps.io.FileOutputController}{Outputs to the current directory of the filesystem}
\entityintro{ServerInputController}{uk.ac.ed.inf.aqmaps.io.ServerInputController}{Implements the Remote interface using a connection to a simple web server.}
\entityintro{WebServer}{uk.ac.ed.inf.aqmaps.io.WebServer}{Handles requesting data from an HTTP server.}
\vskip .1in
\vskip .1in
\section{\label{uk.ac.ed.inf.aqmaps.io.InputController}Interface InputController}{
\hypertarget{uk.ac.ed.inf.aqmaps.io.InputController}{}\vskip .1in 
Handles interaction with input from all remote information sources and devices. Gets information on sensor locations, no-fly zones, W3W locations, and sensor readings. Implementations of the interface can gather the information from any source, such as a simple web server for testing purposes, or from a full system where data is also read from real sensors.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface InputController
\end{lstlisting}
\subsection{All known subinterfaces}{ServerInputController\small{\refdefined{uk.ac.ed.inf.aqmaps.io.ServerInputController}}}
\subsection{All classes known to implement interface}{ServerInputController\small{\refdefined{uk.ac.ed.inf.aqmaps.io.ServerInputController}}}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.io.InputController.getNoFlyZones()}{{\bf getNoFlyZones()}} Gets information about no-fly zones from a remote source\\
\hyperlink{uk.ac.ed.inf.aqmaps.io.InputController.getSensorW3Ws()}{{\bf getSensorW3Ws()}} Gets the list of sensors that need to be visited from a remote source\\
\hyperlink{uk.ac.ed.inf.aqmaps.io.InputController.readSensor(uk.ac.ed.inf.aqmaps.W3W)}{{\bf readSensor(W3W)}} Reads information from the sensor at the provided W3W location\\
\end{verse}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getNoFlyZones()}
\hypertarget{uk.ac.ed.inf.aqmaps.io.InputController.getNoFlyZones()}{{\bf  getNoFlyZones}\\}
\begin{lstlisting}[frame=none]
java.util.List getNoFlyZones()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Gets information about no-fly zones from a remote source
}
\item{{\bf  Returns} -- 
a FeatureCollection containing the locations of the no-fly zones 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSensorW3Ws()}
\hypertarget{uk.ac.ed.inf.aqmaps.io.InputController.getSensorW3Ws()}{{\bf  getSensorW3Ws}\\}
\begin{lstlisting}[frame=none]
java.util.List getSensorW3Ws()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Gets the list of sensors that need to be visited from a remote source
}
\item{{\bf  Returns} -- 
a list of W3W locations of the sensors 
}%end item
\end{itemize}
}%end item
\item{ 
\index{readSensor(W3W)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.InputController.readSensor(uk.ac.ed.inf.aqmaps.W3W)}{{\bf  readSensor}\\}
\begin{lstlisting}[frame=none]
uk.ac.ed.inf.aqmaps.Sensor readSensor(uk.ac.ed.inf.aqmaps.W3W location)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Reads information from the sensor at the provided W3W location
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{location} -- the location of the sensor as a W3W class}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a Sensor object representing the current status of the sensor 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.io.OutputController}Interface OutputController}{
\hypertarget{uk.ac.ed.inf.aqmaps.io.OutputController}{}\vskip .1in 
Handles interaction with all output locations. Implementations may output to any source, such as to a file or to a server.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface OutputController
\end{lstlisting}
\subsection{All known subinterfaces}{FileOutputController\small{\refdefined{uk.ac.ed.inf.aqmaps.io.FileOutputController}}}
\subsection{All classes known to implement interface}{FileOutputController\small{\refdefined{uk.ac.ed.inf.aqmaps.io.FileOutputController}}}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.io.OutputController.outputFlightpath(java.lang.String)}{{\bf outputFlightpath(String)}} Outputs the flightpath planned by the drone\\
\hyperlink{uk.ac.ed.inf.aqmaps.io.OutputController.outputMapGeoJSON(java.lang.String)}{{\bf outputMapGeoJSON(String)}} Outputs the GeoJSON map containing the flightpath and the sensor readings collected by the drone\\
\end{verse}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{outputFlightpath(String)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.OutputController.outputFlightpath(java.lang.String)}{{\bf  outputFlightpath}\\}
\begin{lstlisting}[frame=none]
void outputFlightpath(java.lang.String flightpathText)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Outputs the flightpath planned by the drone
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{flightpathText} -- the String containing the flightpath data}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{outputMapGeoJSON(String)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.OutputController.outputMapGeoJSON(java.lang.String)}{{\bf  outputMapGeoJSON}\\}
\begin{lstlisting}[frame=none]
void outputMapGeoJSON(java.lang.String json)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Outputs the GeoJSON map containing the flightpath and the sensor readings collected by the drone
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{json} -- the GeoJSON String}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.io.Server}Interface Server}{
\hypertarget{uk.ac.ed.inf.aqmaps.io.Server}{}\vskip .1in 
Handles requesting data from a server.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public interface Server
\end{lstlisting}
\subsection{All known subinterfaces}{WebServer\small{\refdefined{uk.ac.ed.inf.aqmaps.io.WebServer}}}
\subsection{All classes known to implement interface}{WebServer\small{\refdefined{uk.ac.ed.inf.aqmaps.io.WebServer}}}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.io.Server.requestData(java.lang.String)}{{\bf requestData(String)}} Request the data that is located at the given URL.\\
\end{verse}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{requestData(String)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.Server.requestData(java.lang.String)}{{\bf  requestData}\\}
\begin{lstlisting}[frame=none]
java.lang.String requestData(java.lang.String url)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Request the data that is located at the given URL. Will cause a fatal error if it cannot connect to the server, or if the requested file is not found.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{url} -- the URL of the file to request}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the requested data as a String 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.io.FileOutputController}Class FileOutputController}{
\hypertarget{uk.ac.ed.inf.aqmaps.io.FileOutputController}{}\vskip .1in 
Outputs to the current directory of the filesystem\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class FileOutputController
 extends java.lang.Object implements OutputController\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.io.FileOutputController.settings}{{\bf settings}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.io.FileOutputController(uk.ac.ed.inf.aqmaps.Settings)}{{\bf FileOutputController(Settings)}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.io.FileOutputController.outputFlightpath(java.lang.String)}{{\bf outputFlightpath(String)}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.io.FileOutputController.outputMapGeoJSON(java.lang.String)}{{\bf outputMapGeoJSON(String)}} \\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{settings}
\label{uk.ac.ed.inf.aqmaps.io.FileOutputController.settings}\hypertarget{uk.ac.ed.inf.aqmaps.io.FileOutputController.settings}{\texttt{private final uk.ac.ed.inf.aqmaps.Settings\ {\bf  settings}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{FileOutputController(Settings)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.FileOutputController(uk.ac.ed.inf.aqmaps.Settings)}{{\bf  FileOutputController}\\}
\begin{lstlisting}[frame=none]
public FileOutputController(uk.ac.ed.inf.aqmaps.Settings settings)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{settings} -- a Settings holding the current input arguments}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{outputFlightpath(String)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.FileOutputController.outputFlightpath(java.lang.String)}{{\bf  outputFlightpath}\\}
\begin{lstlisting}[frame=none]
void outputFlightpath(java.lang.String flightpathText)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{uk.ac.ed.inf.aqmaps.io.OutputController}{OutputController}{\small \refdefined{uk.ac.ed.inf.aqmaps.io.OutputController}} }

Outputs the flightpath planned by the drone
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{flightpathText} -- the String containing the flightpath data}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{outputMapGeoJSON(String)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.FileOutputController.outputMapGeoJSON(java.lang.String)}{{\bf  outputMapGeoJSON}\\}
\begin{lstlisting}[frame=none]
void outputMapGeoJSON(java.lang.String json)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{uk.ac.ed.inf.aqmaps.io.OutputController}{OutputController}{\small \refdefined{uk.ac.ed.inf.aqmaps.io.OutputController}} }

Outputs the GeoJSON map containing the flightpath and the sensor readings collected by the drone
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{json} -- the GeoJSON String}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.io.ServerInputController}Class ServerInputController}{
\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController}{}\vskip .1in 
Implements the Remote interface using a connection to a simple web server.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class ServerInputController
 extends java.lang.Object implements InputController\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.io.ServerInputController.noFlyZones}{{\bf noFlyZones}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.io.ServerInputController.sensorMap}{{\bf sensorMap}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.io.ServerInputController.sensorW3Ws}{{\bf sensorW3Ws}} Note: we need the sensor W3W as a list instead of using keySet() on the map since the set has an undetermined ordering (specifically, not determined by the random seed), which changes the initial random tours generated by the 2-opt algorithm and produces different results with the same random seed.\\
\hyperlink{uk.ac.ed.inf.aqmaps.io.ServerInputController.server}{{\bf server}} Represents the server which we will get data from\\
\hyperlink{uk.ac.ed.inf.aqmaps.io.ServerInputController.serverUrl}{{\bf serverUrl}} The base URL of the server, such as http://localhost:80\\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.io.ServerInputController(uk.ac.ed.inf.aqmaps.io.Server, int, int, int, int)}{{\bf ServerInputController(Server, int, int, int, int)}} Create a new ServerInputController instance with the given Server, date, and port number\\
\hyperlink{uk.ac.ed.inf.aqmaps.io.ServerInputController(uk.ac.ed.inf.aqmaps.Settings)}{{\bf ServerInputController(Settings)}} Create a new ServerInputController instance with the given settings\\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.io.ServerInputController.convertToSensor(uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer)}{{\bf convertToSensor(SensorDeserializer)}} Converts a SensorDeserializer to a Sensor by getting the coordinates of its W3W location from the server.\\
\hyperlink{uk.ac.ed.inf.aqmaps.io.ServerInputController.getNoFlyZones()}{{\bf getNoFlyZones()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.io.ServerInputController.getSensorW3Ws()}{{\bf getSensorW3Ws()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.io.ServerInputController.loadData(int, int, int)}{{\bf loadData(int, int, int)}} Loads the no-fly zones and sensor data from the server into the class fields.\\
\hyperlink{uk.ac.ed.inf.aqmaps.io.ServerInputController.readSensor(uk.ac.ed.inf.aqmaps.W3W)}{{\bf readSensor(W3W)}} \\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{sensorMap}
\label{uk.ac.ed.inf.aqmaps.io.ServerInputController.sensorMap}\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController.sensorMap}{\texttt{private final java.util.HashMap\ {\bf  sensorMap}}
}
}
\item{
\index{sensorW3Ws}
\label{uk.ac.ed.inf.aqmaps.io.ServerInputController.sensorW3Ws}\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController.sensorW3Ws}{\texttt{private final java.util.List\ {\bf  sensorW3Ws}}
}
\begin{itemize}
\item{\vskip -.9ex 
Note: we need the sensor W3W as a list instead of using keySet() on the map since the set has an undetermined ordering (specifically, not determined by the random seed), which changes the initial random tours generated by the 2-opt algorithm and produces different results with the same random seed.}
\end{itemize}
}
\item{
\index{server}
\label{uk.ac.ed.inf.aqmaps.io.ServerInputController.server}\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController.server}{\texttt{private final Server\ {\bf  server}}
}
\begin{itemize}
\item{\vskip -.9ex 
Represents the server which we will get data from}
\end{itemize}
}
\item{
\index{serverUrl}
\label{uk.ac.ed.inf.aqmaps.io.ServerInputController.serverUrl}\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController.serverUrl}{\texttt{private final java.lang.String\ {\bf  serverUrl}}
}
\begin{itemize}
\item{\vskip -.9ex 
The base URL of the server, such as http://localhost:80}
\end{itemize}
}
\item{
\index{noFlyZones}
\label{uk.ac.ed.inf.aqmaps.io.ServerInputController.noFlyZones}\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController.noFlyZones}{\texttt{private java.util.List\ {\bf  noFlyZones}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{ServerInputController(Server, int, int, int, int)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController(uk.ac.ed.inf.aqmaps.io.Server, int, int, int, int)}{{\bf  ServerInputController}\\}
\begin{lstlisting}[frame=none]
public ServerInputController(Server server,int day,int month,int year,int port)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Create a new ServerInputController instance with the given Server, date, and port number
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{server} -- a Server}
   \item{
\texttt{day} -- the day}
   \item{
\texttt{month} -- the month}
   \item{
\texttt{year} -- the year}
   \item{
\texttt{port} -- the port of the server}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{ServerInputController(Settings)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController(uk.ac.ed.inf.aqmaps.Settings)}{{\bf  ServerInputController}\\}
\begin{lstlisting}[frame=none]
public ServerInputController(uk.ac.ed.inf.aqmaps.Settings settings)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Create a new ServerInputController instance with the given settings
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{settings} -- the Settings object containing the current settings}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{convertToSensor(SensorDeserializer)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController.convertToSensor(uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer)}{{\bf  convertToSensor}\\}
\begin{lstlisting}[frame=none]
private uk.ac.ed.inf.aqmaps.Sensor convertToSensor(uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer sensorDeserializer)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Converts a SensorDeserializer to a Sensor by getting the coordinates of its W3W location from the server.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{sensorDeserializer} -- the sensorDeserializer to convert}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
an equivalent Sensor containing its coordinates 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getNoFlyZones()}
\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController.getNoFlyZones()}{{\bf  getNoFlyZones}\\}
\begin{lstlisting}[frame=none]
java.util.List getNoFlyZones()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{uk.ac.ed.inf.aqmaps.io.InputController}{InputController}{\small \refdefined{uk.ac.ed.inf.aqmaps.io.InputController}} }

Gets information about no-fly zones from a remote source
}
\item{{\bf  Returns} -- 
a FeatureCollection containing the locations of the no-fly zones 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getSensorW3Ws()}
\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController.getSensorW3Ws()}{{\bf  getSensorW3Ws}\\}
\begin{lstlisting}[frame=none]
java.util.List getSensorW3Ws()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{uk.ac.ed.inf.aqmaps.io.InputController}{InputController}{\small \refdefined{uk.ac.ed.inf.aqmaps.io.InputController}} }

Gets the list of sensors that need to be visited from a remote source
}
\item{{\bf  Returns} -- 
a list of W3W locations of the sensors 
}%end item
\end{itemize}
}%end item
\item{ 
\index{loadData(int, int, int)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController.loadData(int, int, int)}{{\bf  loadData}\\}
\begin{lstlisting}[frame=none]
private void loadData(int day,int month,int year)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Loads the no-fly zones and sensor data from the server into the class fields.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{day} -- the day}
   \item{
\texttt{month} -- the month}
   \item{
\texttt{year} -- the year}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{readSensor(W3W)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.ServerInputController.readSensor(uk.ac.ed.inf.aqmaps.W3W)}{{\bf  readSensor}\\}
\begin{lstlisting}[frame=none]
uk.ac.ed.inf.aqmaps.Sensor readSensor(uk.ac.ed.inf.aqmaps.W3W location)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{uk.ac.ed.inf.aqmaps.io.InputController}{InputController}{\small \refdefined{uk.ac.ed.inf.aqmaps.io.InputController}} }

Reads information from the sensor at the provided W3W location
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{location} -- the location of the sensor as a W3W class}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a Sensor object representing the current status of the sensor 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.io.WebServer}Class WebServer}{
\hypertarget{uk.ac.ed.inf.aqmaps.io.WebServer}{}\vskip .1in 
Handles requesting data from an HTTP server.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class WebServer
 extends java.lang.Object implements Server\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.io.WebServer.client}{{\bf client}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.io.WebServer()}{{\bf WebServer()}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.io.WebServer.requestData(java.lang.String)}{{\bf requestData(String)}} \\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{client}
\label{uk.ac.ed.inf.aqmaps.io.WebServer.client}\hypertarget{uk.ac.ed.inf.aqmaps.io.WebServer.client}{\texttt{private final java.net.http.HttpClient\ {\bf  client}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{WebServer()}
\hypertarget{uk.ac.ed.inf.aqmaps.io.WebServer()}{{\bf  WebServer}\\}
\begin{lstlisting}[frame=none]
public WebServer()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{requestData(String)}
\hypertarget{uk.ac.ed.inf.aqmaps.io.WebServer.requestData(java.lang.String)}{{\bf  requestData}\\}
\begin{lstlisting}[frame=none]
java.lang.String requestData(java.lang.String url)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description copied from \hyperlink{uk.ac.ed.inf.aqmaps.io.Server}{Server}{\small \refdefined{uk.ac.ed.inf.aqmaps.io.Server}} }

Request the data that is located at the given URL. Will cause a fatal error if it cannot connect to the server, or if the requested file is not found.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{url} -- the URL of the file to request}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the requested data as a String 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
}
\chapter{Package uk.ac.ed.inf.aqmaps.deserializers}{
\label{uk.ac.ed.inf.aqmaps.deserializers}\hypertarget{uk.ac.ed.inf.aqmaps.deserializers}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\hbox{{\bf  Classes}}
\entityintro{CoordsDeserializer}{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer}{Used for deserialization of Coords, this is needed since the field names in Coords inherit from Point2D so @SerializedName can't be used to rename lng and lat to x and y}
\entityintro{SensorDeserializer}{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer}{Used only for deserializing the sensor information from JSON.}
\entityintro{W3WDeserializer}{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer}{Used for deserialization of W3W, \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer}{CoordsDeserializer}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer}} for why this is necessary.}
\vskip .1in
\vskip .1in
\section{\label{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer}Class CoordsDeserializer}{
\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer}{}\vskip .1in 
Used for deserialization of Coords, this is needed since the field names in Coords inherit from Point2D so @SerializedName can't be used to rename lng and lat to x and y\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class CoordsDeserializer
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer.lat}{{\bf lat}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer.lng}{{\bf lng}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer()}{{\bf CoordsDeserializer()}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer.getCoords()}{{\bf getCoords()}} \\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{lng}
\label{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer.lng}\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer.lng}{\texttt{private double\ {\bf  lng}}
}
}
\item{
\index{lat}
\label{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer.lat}\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer.lat}{\texttt{private double\ {\bf  lat}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{CoordsDeserializer()}
\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer()}{{\bf  CoordsDeserializer}\\}
\begin{lstlisting}[frame=none]
public CoordsDeserializer()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getCoords()}
\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer.getCoords()}{{\bf  getCoords}\\}
\begin{lstlisting}[frame=none]
public uk.ac.ed.inf.aqmaps.geometry.Coords getCoords()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
a Coords object 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer}Class SensorDeserializer}{
\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer}{}\vskip .1in 
Used only for deserializing the sensor information from JSON. The real Sensor class stores the location as W3W instead of a String.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class SensorDeserializer
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.battery}{{\bf battery}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.location}{{\bf location}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.reading}{{\bf reading}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer()}{{\bf SensorDeserializer()}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.getBattery()}{{\bf getBattery()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.getLocation()}{{\bf getLocation()}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.getReading()}{{\bf getReading()}} \\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{location}
\label{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.location}\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.location}{\texttt{private java.lang.String\ {\bf  location}}
}
}
\item{
\index{battery}
\label{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.battery}\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.battery}{\texttt{private float\ {\bf  battery}}
}
}
\item{
\index{reading}
\label{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.reading}\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.reading}{\texttt{private java.lang.String\ {\bf  reading}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{SensorDeserializer()}
\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer()}{{\bf  SensorDeserializer}\\}
\begin{lstlisting}[frame=none]
public SensorDeserializer()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getBattery()}
\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.getBattery()}{{\bf  getBattery}\\}
\begin{lstlisting}[frame=none]
public float getBattery()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the battery level of this sensor as a percentage 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getLocation()}
\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.getLocation()}{{\bf  getLocation}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getLocation()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the location of the sensor as a W3W string 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getReading()}
\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer.getReading()}{{\bf  getReading}\\}
\begin{lstlisting}[frame=none]
public java.lang.String getReading()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
the reading of the sensor, as a String 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer}Class W3WDeserializer}{
\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer}{}\vskip .1in 
Used for deserialization of W3W, \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer}{CoordsDeserializer}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.deserializers.CoordsDeserializer}} for why this is necessary.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class W3WDeserializer
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer.coordinates}{{\bf coordinates}} \\
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer.words}{{\bf words}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer()}{{\bf W3WDeserializer()}} \\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer.getW3W()}{{\bf getW3W()}} \\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{coordinates}
\label{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer.coordinates}\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer.coordinates}{\texttt{private CoordsDeserializer\ {\bf  coordinates}}
}
}
\item{
\index{words}
\label{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer.words}\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer.words}{\texttt{private java.lang.String\ {\bf  words}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{W3WDeserializer()}
\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer()}{{\bf  W3WDeserializer}\\}
\begin{lstlisting}[frame=none]
public W3WDeserializer()\end{lstlisting} %end signature
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getW3W()}
\hypertarget{uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer.getW3W()}{{\bf  getW3W}\\}
\begin{lstlisting}[frame=none]
public uk.ac.ed.inf.aqmaps.W3W getW3W()\end{lstlisting} %end signature
\begin{itemize}
\item{{\bf  Returns} -- 
a W3W object 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
}
\chapter{Package uk.ac.ed.inf.aqmaps.noflyzone}{
\label{uk.ac.ed.inf.aqmaps.noflyzone}\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone}{}
\hskip -.05in
\hbox to \hsize{\textit{ Package Contents\hfil Page}}
\vskip .13in
\hbox{{\bf  Classes}}
\entityintro{ObstacleGraph}{uk.ac.ed.inf.aqmaps.noflyzone.ObstacleGraph}{A graph of the vertices of the obstacles and edges between them if they have line of sight.}
\entityintro{ObstaclePathfinder}{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder}{Handles obstacle evasion.}
\entityintro{Obstacles}{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles}{Holds information about the obstacles or no-fly zones that the drone must avoid.}
\vskip .1in
\vskip .1in
\section{\label{uk.ac.ed.inf.aqmaps.noflyzone.ObstacleGraph}Class ObstacleGraph}{
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.ObstacleGraph}{}\vskip .1in 
A graph of the vertices of the obstacles and edges between them if they have line of sight.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class ObstacleGraph
 extends org.jgrapht.graph.SimpleWeightedGraph\end{lstlisting}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.ObstacleGraph(uk.ac.ed.inf.aqmaps.noflyzone.Obstacles, java.util.List)}{{\bf ObstacleGraph(Obstacles, List)}} Constructor\\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.ObstacleGraph.prepareGraph(java.util.List, uk.ac.ed.inf.aqmaps.noflyzone.Obstacles)}{{\bf prepareGraph(List, Obstacles)}} Prepare a weighted graph containing all points which form an outline around the polygons as vertices, and edges connecting them if they have line of sight, which have a weight equal to the distance between them.\\
\end{verse}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{ObstacleGraph(Obstacles, List)}
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.ObstacleGraph(uk.ac.ed.inf.aqmaps.noflyzone.Obstacles, java.util.List)}{{\bf  ObstacleGraph}\\}
\begin{lstlisting}[frame=none]
private ObstacleGraph(Obstacles obstacles,java.util.List outlinePoints)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Constructor
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{outlinePoints} -- the points which form the outline of the obstacle polygons}
   \item{
\texttt{obstacles} -- the obstacles to prepare the graph for}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{prepareGraph(List, Obstacles)}
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.ObstacleGraph.prepareGraph(java.util.List, uk.ac.ed.inf.aqmaps.noflyzone.Obstacles)}{{\bf  prepareGraph}\\}
\begin{lstlisting}[frame=none]
public static ObstacleGraph prepareGraph(java.util.List outlinePoints,Obstacles obstacles)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Prepare a weighted graph containing all points which form an outline around the polygons as vertices, and edges connecting them if they have line of sight, which have a weight equal to the distance between them. The graph uses outline polygons since if it used the original polygons, their points would occupy the same location and any line emerging from the corner of an obstacle would be considered to be colliding with it. See see \texttt{\small \hyperlink{uk.ac.ed.inf.aqmaps.geometry.Polygon.generateOutlinePoints()}{generateOutlinePoints()}}{\small 
\refdefined{uk.ac.ed.inf.aqmaps.geometry.Polygon.generateOutlinePoints()}}.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{outlinePoints} -- the points which form the outline of the obstacle polygons}
   \item{
\texttt{obstacles} -- the obstacles to prepare the graph for}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a graph representation of the obstacles 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Members inherited from class SimpleWeightedGraph }{
\texttt{org.jgrapht.graph.SimpleWeightedGraph} {\small 
\refdefined{org.jgrapht.graph.SimpleWeightedGraph}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public static GraphBuilder {\bf  createBuilder}(\texttt{java.lang.Class} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static GraphBuilder {\bf  createBuilder}(\texttt{java.util.function.Supplier} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  serialVersionUID}}%end signature
}%end item
\end{itemize}
}
\subsection{Members inherited from class SimpleGraph }{
\texttt{org.jgrapht.graph.SimpleGraph} {\small 
\refdefined{org.jgrapht.graph.SimpleGraph}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public static GraphBuilder {\bf  createBuilder}(\texttt{java.lang.Class} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public static GraphBuilder {\bf  createBuilder}(\texttt{java.util.function.Supplier} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  serialVersionUID}}%end signature
}%end item
\end{itemize}
}
\subsection{Members inherited from class AbstractBaseGraph }{
\texttt{org.jgrapht.graph.AbstractBaseGraph} {\small 
\refdefined{org.jgrapht.graph.AbstractBaseGraph}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{public Object {\bf  addEdge}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  addEdge}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1},
\texttt{java.lang.Object} {\bf  arg2})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Object {\bf  addVertex}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  addVertex}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Object {\bf  clone}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  containsEdge}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  containsVertex}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public int {\bf  degreeOf}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  edgeSet}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  edgesOf}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  edgeSupplier}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  getAllEdges}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Object {\bf  getEdge}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Object {\bf  getEdgeSource}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Supplier {\bf  getEdgeSupplier}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Object {\bf  getEdgeTarget}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public double {\bf  getEdgeWeight}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public GraphType {\bf  getType}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Supplier {\bf  getVertexSupplier}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  GRAPH\_SPECIFICS\_MUST\_NOT\_BE\_NULL}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  GRAPH\_SPECIFICS\_STRATEGY\_REQUIRED}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  graphSpecificsStrategy}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  incomingEdgesOf}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public int {\bf  inDegreeOf}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  intrusiveEdgesSpecifics}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  INVALID\_VERTEX\_SUPPLIER\_DOES\_NOT\_RETURN\_UNIQUE\_VERTICES\_ON\_EACH\_CALL}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  LOOPS\_NOT\_ALLOWED}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  MIXED\_GRAPH\_NOT\_SUPPORTED}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public int {\bf  outDegreeOf}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  outgoingEdgesOf}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  removeEdge}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Object {\bf  removeEdge}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  removeVertex}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  serialVersionUID}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public void {\bf  setEdgeSupplier}(\texttt{java.util.function.Supplier} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public void {\bf  setEdgeWeight}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{double} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public void {\bf  setVertexSupplier}(\texttt{java.util.function.Supplier} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  specifics}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  THE\_GRAPH\_CONTAINS\_NO\_EDGE\_SUPPLIER}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private static final {\bf  THE\_GRAPH\_CONTAINS\_NO\_VERTEX\_SUPPLIER}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  type}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private transient {\bf  unmodifiableVertexSet}}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  vertexSet}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{private {\bf  vertexSupplier}}%end signature
}%end item
\end{itemize}
}
\subsection{Members inherited from class AbstractGraph }{
\texttt{org.jgrapht.graph.AbstractGraph} {\small 
\refdefined{org.jgrapht.graph.AbstractGraph}}
{\small 

\vskip -2em
\begin{itemize}
\item{\vskip -1.5ex 
\texttt{protected boolean {\bf  assertVertexExist}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  containsEdge}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  equals}(\texttt{java.lang.Object} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public int {\bf  hashCode}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  removeAllEdges}(\texttt{java.util.Collection} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected boolean {\bf  removeAllEdges}(\texttt{java.lang.Object\lbrack \rbrack } {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public Set {\bf  removeAllEdges}(\texttt{java.lang.Object} {\bf  arg0},
\texttt{java.lang.Object} {\bf  arg1})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public boolean {\bf  removeAllVertices}(\texttt{java.util.Collection} {\bf  arg0})
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{public String {\bf  toString}()
}%end signature
}%end item
\item{\vskip -1.5ex 
\texttt{protected String {\bf  toStringFromSets}(\texttt{java.util.Collection} {\bf  arg0},
\texttt{java.util.Collection} {\bf  arg1},
\texttt{boolean} {\bf  arg2})
}%end signature
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder}Class ObstaclePathfinder}{
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder}{}\vskip .1in 
Handles obstacle evasion. Uses Obstacles and an ObstacleGraph to find paths between points which do not collides with any obstacles.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class ObstaclePathfinder
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.graph}{{\bf graph}} A weighted graph containing all points which form an outline around the polygons as vertices, and edges connecting them if they have line of sight, which have a weight equal to the distance between them.\\
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.obstacles}{{\bf obstacles}} \\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder(uk.ac.ed.inf.aqmaps.noflyzone.ObstacleGraph, uk.ac.ed.inf.aqmaps.noflyzone.Obstacles)}{{\bf ObstaclePathfinder(ObstacleGraph, Obstacles)}} Construct an Obstacle evader with the given graph and obstacles.\\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.addEdgeIfHasLineOfSight(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf addEdgeIfHasLineOfSight(Coords, Coords)}} Adds an edge between points A and B if they have line of sight to each other, or in other words if the line between them does not collide with an obstacle.\\
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.getPathBetweenPoints(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf getPathBetweenPoints(Coords, Coords)}} Find the shortest path between the start and end points, navigating around obstacles if necessary.\\
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.getShortestPath(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf getShortestPath(Coords, Coords)}} Computes a GraphPath containing the shortest path from the start to the end coordinates, navigating around obstacles if required.\\
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.getShortestPathLength(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf getShortestPathLength(Coords, Coords)}} Find the length of the shortest path between the start and end points, navigating around obstacles if necessary.\\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{graph}
\label{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.graph}\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.graph}{\texttt{private final ObstacleGraph\ {\bf  graph}}
}
\begin{itemize}
\item{\vskip -.9ex 
A weighted graph containing all points which form an outline around the polygons as vertices, and edges connecting them if they have line of sight, which have a weight equal to the distance between them.}
\end{itemize}
}
\item{
\index{obstacles}
\label{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.obstacles}\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.obstacles}{\texttt{private final Obstacles\ {\bf  obstacles}}
}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{ObstaclePathfinder(ObstacleGraph, Obstacles)}
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder(uk.ac.ed.inf.aqmaps.noflyzone.ObstacleGraph, uk.ac.ed.inf.aqmaps.noflyzone.Obstacles)}{{\bf  ObstaclePathfinder}\\}
\begin{lstlisting}[frame=none]
public ObstaclePathfinder(ObstacleGraph graph,Obstacles obstacles)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Construct an Obstacle evader with the given graph and obstacles.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{graph} -- a graph of the obstacles}
   \item{
\texttt{obstacles} -- the Obstacles}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{addEdgeIfHasLineOfSight(Coords, Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.addEdgeIfHasLineOfSight(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  addEdgeIfHasLineOfSight}\\}
\begin{lstlisting}[frame=none]
private void addEdgeIfHasLineOfSight(uk.ac.ed.inf.aqmaps.geometry.Coords A,uk.ac.ed.inf.aqmaps.geometry.Coords B)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Adds an edge between points A and B if they have line of sight to each other, or in other words if the line between them does not collide with an obstacle. Sets the edge weight to the distance between the points.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{A} -- point A}
   \item{
\texttt{B} -- point B}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\item{ 
\index{getPathBetweenPoints(Coords, Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.getPathBetweenPoints(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  getPathBetweenPoints}\\}
\begin{lstlisting}[frame=none]
public java.util.List getPathBetweenPoints(uk.ac.ed.inf.aqmaps.geometry.Coords start,uk.ac.ed.inf.aqmaps.geometry.Coords end)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Find the shortest path between the start and end points, navigating around obstacles if necessary.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{start} -- the starting point}
   \item{
\texttt{end} -- the ending point}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a list of points specifying the route 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getShortestPath(Coords, Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.getShortestPath(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  getShortestPath}\\}
\begin{lstlisting}[frame=none]
private org.jgrapht.GraphPath getShortestPath(uk.ac.ed.inf.aqmaps.geometry.Coords start,uk.ac.ed.inf.aqmaps.geometry.Coords end)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Computes a GraphPath containing the shortest path from the start to the end coordinates, navigating around obstacles if required.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{start} -- the start point}
   \item{
\texttt{end} -- the end point}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
a GraphPath 
}%end item
\end{itemize}
}%end item
\item{ 
\index{getShortestPathLength(Coords, Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.ObstaclePathfinder.getShortestPathLength(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  getShortestPathLength}\\}
\begin{lstlisting}[frame=none]
public double getShortestPathLength(uk.ac.ed.inf.aqmaps.geometry.Coords start,uk.ac.ed.inf.aqmaps.geometry.Coords end)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Find the length of the shortest path between the start and end points, navigating around obstacles if necessary. Euclidean distance is used as the length measure.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{start} -- the starting point}
   \item{
\texttt{end} -- the ending point}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
the length of the path in degrees 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
\section{\label{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles}Class Obstacles}{
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles}{}\vskip .1in 
Holds information about the obstacles or no-fly zones that the drone must avoid.\vskip .1in 
\subsection{Declaration}{
\begin{lstlisting}[frame=none]
public class Obstacles
 extends java.lang.Object\end{lstlisting}
\subsection{Field summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.BOTTOM_RIGHT}{{\bf BOTTOM\_RIGHT}} A Point representing the southeast corner of the confinement area.\\
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.graph}{{\bf graph}} A weighted graph containing all points which form an outline around the polygons as vertices, and edges connecting them if they have line of sight, which have a weight equal to the distance between them.\\
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.polygons}{{\bf polygons}} A list of the Polygon representations of the obstacles\\
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.TOP_LEFT}{{\bf TOP\_LEFT}} A Point representing the northwest corner of the confinement area.\\
\end{verse}
}
\subsection{Constructor summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles(java.util.List)}{{\bf Obstacles(List)}} Constructs Obstacles out of a list of Polygons specifying their locations\\
\end{verse}
}
\subsection{Method summary}{
\begin{verse}
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.getObstaclePathfinder()}{{\bf getObstaclePathfinder()}} Gets an ObstaclePathfinder using these Obstacles.\\
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.isInConfinement(uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf isInConfinement(Coords)}} Determines whether or not a point is inside the confinement area\\
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.lineCollision(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf lineCollision(Coords, Coords)}} Determines whether the line segment between the start and end points collides with a obstacle.\\
\hyperlink{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.pointCollides(uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf pointCollides(Coords)}} Determine whether the given point is inside an obstacle, or outside the confinement area.\\
\end{verse}
}
\subsection{Fields}{
\begin{itemize}
\item{
\index{TOP\_LEFT}
\label{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.TOP_LEFT}\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.TOP_LEFT}{\texttt{public static final uk.ac.ed.inf.aqmaps.geometry.Coords\ {\bf  TOP\_LEFT}}
}
\begin{itemize}
\item{\vskip -.9ex 
A Point representing the northwest corner of the confinement area.}
\end{itemize}
}
\item{
\index{BOTTOM\_RIGHT}
\label{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.BOTTOM_RIGHT}\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.BOTTOM_RIGHT}{\texttt{public static final uk.ac.ed.inf.aqmaps.geometry.Coords\ {\bf  BOTTOM\_RIGHT}}
}
\begin{itemize}
\item{\vskip -.9ex 
A Point representing the southeast corner of the confinement area.}
\end{itemize}
}
\item{
\index{graph}
\label{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.graph}\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.graph}{\texttt{private final ObstacleGraph\ {\bf  graph}}
}
\begin{itemize}
\item{\vskip -.9ex 
A weighted graph containing all points which form an outline around the polygons as vertices, and edges connecting them if they have line of sight, which have a weight equal to the distance between them.}
\end{itemize}
}
\item{
\index{polygons}
\label{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.polygons}\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.polygons}{\texttt{private final java.util.List\ {\bf  polygons}}
}
\begin{itemize}
\item{\vskip -.9ex 
A list of the Polygon representations of the obstacles}
\end{itemize}
}
\end{itemize}
}
\subsection{Constructors}{
\vskip -2em
\begin{itemize}
\item{ 
\index{Obstacles(List)}
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles(java.util.List)}{{\bf  Obstacles}\\}
\begin{lstlisting}[frame=none]
public Obstacles(java.util.List polygons)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Constructs Obstacles out of a list of Polygons specifying their locations
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{polygons} -- the Polygons which make up the obstacles}
  \end{itemize}
}%end item
\end{itemize}
}%end item
\end{itemize}
}
\subsection{Methods}{
\vskip -2em
\begin{itemize}
\item{ 
\index{getObstaclePathfinder()}
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.getObstaclePathfinder()}{{\bf  getObstaclePathfinder}\\}
\begin{lstlisting}[frame=none]
public ObstaclePathfinder getObstaclePathfinder()\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Gets an ObstaclePathfinder using these Obstacles. The ObstaclePathfinder uses a clone of the obstacle graph, allowing it to be used concurrently with other ObstaclePathfinder.
}
\item{{\bf  Returns} -- 
an ObstaclePathfinder instance with these obstacles 
}%end item
\end{itemize}
}%end item
\item{ 
\index{isInConfinement(Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.isInConfinement(uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  isInConfinement}\\}
\begin{lstlisting}[frame=none]
public boolean isInConfinement(uk.ac.ed.inf.aqmaps.geometry.Coords point)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Determines whether or not a point is inside the confinement area
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{point} -- the point to examine}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
true if the point is inside the confinement area, false otherwise 
}%end item
\end{itemize}
}%end item
\item{ 
\index{lineCollision(Coords, Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.lineCollision(uk.ac.ed.inf.aqmaps.geometry.Coords, uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  lineCollision}\\}
\begin{lstlisting}[frame=none]
public boolean lineCollision(uk.ac.ed.inf.aqmaps.geometry.Coords start,uk.ac.ed.inf.aqmaps.geometry.Coords end)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Determines whether the line segment between the start and end points collides with a obstacle.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{start} -- the coordinates of the start point}
   \item{
\texttt{end} -- the coordinates of the end point}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
true if the segment collides with an obstacle, false otherwise 
}%end item
\end{itemize}
}%end item
\item{ 
\index{pointCollides(Coords)}
\hypertarget{uk.ac.ed.inf.aqmaps.noflyzone.Obstacles.pointCollides(uk.ac.ed.inf.aqmaps.geometry.Coords)}{{\bf  pointCollides}\\}
\begin{lstlisting}[frame=none]
public boolean pointCollides(uk.ac.ed.inf.aqmaps.geometry.Coords coords)\end{lstlisting} %end signature
\begin{itemize}
\item{
{\bf  Description}

Determine whether the given point is inside an obstacle, or outside the confinement area. This is currently only used in testing to generate random starting points.
}
\item{
{\bf  Parameters}
  \begin{itemize}
   \item{
\texttt{coords} -- the point}
  \end{itemize}
}%end item
\item{{\bf  Returns} -- 
true if there is a collision, false otherwise 
}%end item
\end{itemize}
}%end item
\end{itemize}
}
}
}
\end{document}
