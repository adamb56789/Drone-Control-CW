package uk.ac.ed.inf.aqmaps.flightplanning;

import uk.ac.ed.inf.aqmaps.geometry.Coords;

import java.util.Objects;

/**
 * A class which holds data about the input values of the flight planning algorithm from a position
 * to a sensor, potentially with a next sensor. This is for use in the cache, so stores hashed value
 * directly in order to save memory and time calculating extra hashes.
 */
public class FlightCacheKey {
  /** A hash of the parameters */
  private final int hashcode;
  private final int startHash;
  private final int currentHash;
  private final int nextHash;

  /**
   * Constructor
   *
   * @param startPosition the start position of the drone.
   * @param currentTarget the current target
   * @param nextTarget the next target if there is one, or null otherwise
   */
  public FlightCacheKey(Coords startPosition, Coords currentTarget, Coords nextTarget) {
    // Hash the coordinates. Point2D has an appropriate built in hashMap() which is used
    // It is not necessary to null check nextTarget and use something else instead, because it
    // already does the same thing (element == null ? 0 : element.hashCode()) (in Arrays.hashCode())
    hashcode = Objects.hash(startPosition, currentTarget, nextTarget);
    startHash = startPosition.hashCode();
    currentHash = currentTarget.hashCode();
    nextHash = nextTarget == null ? 0 : nextTarget.hashCode();
  }

  /** Needed to work with a HashMap, automatically generated by IntelliJ. */
  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    FlightCacheKey that = (FlightCacheKey) o;
    return hashcode == that.hashcode
        && startHash == that.startHash
        && currentHash == that.currentHash
        && nextHash == that.nextHash;
  }

  /**
   * Since this class stores the hashcode directly, we do not do any computation and just return it.
   */
  @Override
  public int hashCode() {
    return hashcode;
  }
}
