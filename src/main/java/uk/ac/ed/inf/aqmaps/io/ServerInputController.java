package uk.ac.ed.inf.aqmaps.io;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.mapbox.geojson.FeatureCollection;
import uk.ac.ed.inf.aqmaps.Sensor;
import uk.ac.ed.inf.aqmaps.Settings;
import uk.ac.ed.inf.aqmaps.W3W;
import uk.ac.ed.inf.aqmaps.deserializers.SensorDeserializer;
import uk.ac.ed.inf.aqmaps.deserializers.W3WDeserializer;
import uk.ac.ed.inf.aqmaps.geometry.Polygon;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.stream.Collectors;

/** Implements the Remote interface using a connection to a simple web server. */
public class ServerInputController implements InputController {
  private final HashMap<W3W, Sensor> sensorMap = new HashMap<>();

  /**
   * Note: we need the sensor W3W as a list instead of using keySet() on the map since the set has
   * an undetermined ordering (specifically, not determined by the random seed), which changes the
   * initial random tours generated by the 2-opt algorithm and produces different results with the
   * same random seed.
   */
  private final List<W3W> sensorW3Ws = new ArrayList<>();

  /** Represents the server which we will get data from */
  private final Server server;

  /** The base URL of the server, such as http://localhost:80 */
  private final String serverUrl;

  private List<Polygon> noFlyZones;

  /**
   * Create a new ServerInputController instance with the given settings
   *
   * @param settings the Settings object containing the current settings
   */
  public ServerInputController(Settings settings) {
    this(
        new WebServer(),
        settings.getDay(),
        settings.getMonth(),
        settings.getYear(),
        settings.getPort());
  }

  /**
   * Create a new ServerInputController instance with the given Server, date, and port number
   *
   * @param server a Server
   * @param day the day
   * @param month the month
   * @param year the year
   * @param port the port of the server
   */
  public ServerInputController(Server server, int day, int month, int year, int port) {
    this.server = server;
    serverUrl = "http://localhost:" + port;
    loadData(day, month, year);
  }

  /**
   * Loads the no-fly zones and sensor data from the server into the class fields.
   *
   * @param day the day
   * @param month the month
   * @param year the year
   */
  private void loadData(int day, int month, int year) {
    // Load no-fly zones
    String url = serverUrl + "/buildings/no-fly-zones.geojson";
    String nfzJson = server.requestData(url);
    //noinspection ConstantConditions
    noFlyZones =
        FeatureCollection.fromJson(nfzJson).features().stream()
            .map(Polygon::buildFromFeature)
            .collect(Collectors.toList());

    // Load today's sensors
    url =
        String.format("%s/maps/%04d/%02d/%02d/air-quality-data.json", serverUrl, year, month, day);
    String sensorJson = server.requestData(url);

    // Deserialize the air quality data into SensorDeserializer objects. A separate class is used
    // for deserialization since the JSON contains the location as a word string only, but we want
    // to internally represent the sensor with a W3W object which also contains the coordinates.
    Type listType = new TypeToken<ArrayList<SensorDeserializer>>() {}.getType();
    ArrayList<SensorDeserializer> sensorDeserializers = new Gson().fromJson(sensorJson, listType);

    // Convert the list of SensorDeserializers to a list of Sensors
    var sensors =
        sensorDeserializers.stream()
            .map(this::convertToSensor)
            .collect(Collectors.toCollection(ArrayList::new));

    // Put locations and their corresponding sensor into a Map for later access by readSensor()
    for (var sensor : sensors) {
      sensorMap.put(sensor.getLocation(), sensor);
      sensorW3Ws.add(sensor.getLocation());
    }
  }

  /**
   * Converts a SensorDeserializer to a Sensor by getting the coordinates of its W3W location from
   * the server.
   *
   * @param sensorDeserializer the sensorDeserializer to convert
   * @return an equivalent Sensor containing its coordinates
   */
  private Sensor convertToSensor(SensorDeserializer sensorDeserializer) {
    // Get the appropriate W3W object from the server
    // Example url: http://localhost:80/words/dent/shins/cycle/details.json
    String url =
        serverUrl
            + "/words/"
            + sensorDeserializer.getLocation().replace('.', '/')
            + "/details.json";
    String w3wJson = server.requestData(url);
    var w3w = (new Gson().fromJson(w3wJson, W3WDeserializer.class)).getW3W();

    return new Sensor(w3w, sensorDeserializer.getBattery(), sensorDeserializer.getReading());
  }

  @Override
  public Sensor readSensor(W3W location) {
    return sensorMap.get(location);
  }

  @Override
  public List<W3W> getSensorW3Ws() {
    return new ArrayList<>(sensorW3Ws);
  }

  @Override
  public List<Polygon> getNoFlyZones() {
    return noFlyZones;
  }
}
